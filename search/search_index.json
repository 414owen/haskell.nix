{
    "docs": [
        {
            "location": "/", 
            "text": "haskell.nix\n\n\nhaskell.nix is an alternative Haskell infrastructure for nixpkgs. See\n\nNixpkgs current Users' Guide to Haskell Infrastructure\n for comparison.\n\n\nMotivation\n\n\nWhy do we need another Haskell infrastructure for nix?  Doesn't nixpkgs\nprovide a sufficiently good Haskell infrastructure already?  These are\ngood questions.  And it boils down to the following reasons for us to\nembark on a new infrastructure:\n\n\n\n\nfirst class support for cross compilation\n\n\nfirst class support for package sets\n\n\ncomponent level control when building packages\n\n\nreduction of \ndontCheck\n for cyclic dependencies\n\n\nreducing build times by building libraries and tests in parallel\n\n\nmore logic encoded in nix expressions\n\n\ndecoupling of Haskell and nixpkgs\n\n\n\n\ncross compilation\n\n\nnixpkgs\n has quite good support for cross compilation, however the\nHaskell infrastructure suffers from the fact that it heavily relies on\nthe \ncabal2nix\n tool.  \ncabal2nix\n (as well as tools that depend on it\nlike \nstack2nix\n) flattens the \n.cabal\n file at conversion time to a\ngiven os/arch/flags configuration.  Thus to make cross compilation\nwork with \ncabal2nix\n you will have to generate a separate \nnix\n\nexpression for each configuration.  This becomes a major maintenance\nburden over time.  Therefore the tooling that translates cabal files\ninto nix-expressions for use with Haskell.nix retains the full\nconditional tree from the cabal file and exposes it to \nnix\n.  In\naddition it will also expose the \nbuild-type\n value, which allows us\nto cache the \nSetup.hs\n for build-type simple and not have to rebuild\nit every time.\n\n\npackage sets\n\n\nWe often rely on either package sets as provided by stackage or\ncomputed by cabal.  \nnixpkgs\n provides it's own curated package set\nwhich might or might not work for the projects we work on.\n\nstack2nix\n tries to solve this issue, here we go one step further and\nprovide the infrastructure to allow any form of package set.\n\n\ncomponent level control\n\n\nThe Haskell builder in \nnixpkgs\n provides control over executables and\nlibraries, to build a specific executable only however is rather\ntricky to do.  This also leads to the cyclic dependencies issue.\n\n\ncyclic dependencies\n\n\nBecause the Haskell builder in \nnixpkgs\n exposes packages at the\npackage level, if packages mutually depend on each other through tests\nand libraries, lead to cyclic dependencies that nix can't resolve.  By\nexposing the components to nix as separate derivations this will only\noccur if you have mutually dependent components.\n\n\nbuild times\n\n\nThe Haskell builder in nixpkgs build package sequentially, first the\nlibrary than the executables and finally the tests.  It then executes\nthe tests before the package is considered done.  The upshot of this\nis that packages are only considered done if the test-suites\npassed.  The downside is that if you have to compile multiple packages\nthe likelihood of them failing is low, you have unnecessarily\nserialized you build.  In a more aggressive setting libraries could\nstart building as early as their dependent libraries are built.  Of\ncourse they will have to be invalidated later should the test-suites\nof their dependencies fail, but this way we can make use of parallel\nbuilding.  In an ideal scenario this will reduce build times close to\nthe optimum.\n\n\nmore logic in nix\n\n\nThe \ncabal2nix\n tool has a resolver that resolved system dependencies\nand licenses to values in \nnixpkgs\n.  This logic end up being a simple\ndictionary lookup and can be a simple nix expression.  This also\noffloads some of the work the cabal to nix translation tool needs to\ndo into nix, and as such if changes are necessary (or needed to be\nperformed ad hoc) there is no need to rebuild the conversion tool and\nsubsequently mark every derived expression as out of date.\n\n\ndecoupleing\n\n\nFinally by treating Haskell.nix and nixpkgs as separate entities we\ncan decouple the Haskell packages and infrastructure from the nixpkgs\npackage set, and rely on it to provide us with system packages while\nstaying up to date with Haskell packages from hackage while retaining\na stable (or known to be good) nixpkgs revision.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#haskellnix", 
            "text": "haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure  for comparison.", 
            "title": "haskell.nix"
        }, 
        {
            "location": "/#motivation", 
            "text": "Why do we need another Haskell infrastructure for nix?  Doesn't nixpkgs\nprovide a sufficiently good Haskell infrastructure already?  These are\ngood questions.  And it boils down to the following reasons for us to\nembark on a new infrastructure:   first class support for cross compilation  first class support for package sets  component level control when building packages  reduction of  dontCheck  for cyclic dependencies  reducing build times by building libraries and tests in parallel  more logic encoded in nix expressions  decoupling of Haskell and nixpkgs", 
            "title": "Motivation"
        }, 
        {
            "location": "/#cross-compilation", 
            "text": "nixpkgs  has quite good support for cross compilation, however the\nHaskell infrastructure suffers from the fact that it heavily relies on\nthe  cabal2nix  tool.   cabal2nix  (as well as tools that depend on it\nlike  stack2nix ) flattens the  .cabal  file at conversion time to a\ngiven os/arch/flags configuration.  Thus to make cross compilation\nwork with  cabal2nix  you will have to generate a separate  nix \nexpression for each configuration.  This becomes a major maintenance\nburden over time.  Therefore the tooling that translates cabal files\ninto nix-expressions for use with Haskell.nix retains the full\nconditional tree from the cabal file and exposes it to  nix .  In\naddition it will also expose the  build-type  value, which allows us\nto cache the  Setup.hs  for build-type simple and not have to rebuild\nit every time.", 
            "title": "cross compilation"
        }, 
        {
            "location": "/#package-sets", 
            "text": "We often rely on either package sets as provided by stackage or\ncomputed by cabal.   nixpkgs  provides it's own curated package set\nwhich might or might not work for the projects we work on. stack2nix  tries to solve this issue, here we go one step further and\nprovide the infrastructure to allow any form of package set.", 
            "title": "package sets"
        }, 
        {
            "location": "/#component-level-control", 
            "text": "The Haskell builder in  nixpkgs  provides control over executables and\nlibraries, to build a specific executable only however is rather\ntricky to do.  This also leads to the cyclic dependencies issue.", 
            "title": "component level control"
        }, 
        {
            "location": "/#cyclic-dependencies", 
            "text": "Because the Haskell builder in  nixpkgs  exposes packages at the\npackage level, if packages mutually depend on each other through tests\nand libraries, lead to cyclic dependencies that nix can't resolve.  By\nexposing the components to nix as separate derivations this will only\noccur if you have mutually dependent components.", 
            "title": "cyclic dependencies"
        }, 
        {
            "location": "/#build-times", 
            "text": "The Haskell builder in nixpkgs build package sequentially, first the\nlibrary than the executables and finally the tests.  It then executes\nthe tests before the package is considered done.  The upshot of this\nis that packages are only considered done if the test-suites\npassed.  The downside is that if you have to compile multiple packages\nthe likelihood of them failing is low, you have unnecessarily\nserialized you build.  In a more aggressive setting libraries could\nstart building as early as their dependent libraries are built.  Of\ncourse they will have to be invalidated later should the test-suites\nof their dependencies fail, but this way we can make use of parallel\nbuilding.  In an ideal scenario this will reduce build times close to\nthe optimum.", 
            "title": "build times"
        }, 
        {
            "location": "/#more-logic-in-nix", 
            "text": "The  cabal2nix  tool has a resolver that resolved system dependencies\nand licenses to values in  nixpkgs .  This logic end up being a simple\ndictionary lookup and can be a simple nix expression.  This also\noffloads some of the work the cabal to nix translation tool needs to\ndo into nix, and as such if changes are necessary (or needed to be\nperformed ad hoc) there is no need to rebuild the conversion tool and\nsubsequently mark every derived expression as out of date.", 
            "title": "more logic in nix"
        }, 
        {
            "location": "/#decoupleing", 
            "text": "Finally by treating Haskell.nix and nixpkgs as separate entities we\ncan decouple the Haskell packages and infrastructure from the nixpkgs\npackage set, and rely on it to provide us with system packages while\nstaying up to date with Haskell packages from hackage while retaining\na stable (or known to be good) nixpkgs revision.", 
            "title": "decoupleing"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nThere are multiple components that play a part in the haskell.nix\ninfrastructure.  These are \nnix-tools\n, \nhaskell.nix\n, \nhackage.nix\n,\nand \nstackage.nix\n.\n\n\n                                             .-------------.     .-------------.\n.- nix-tools ------.                         | haskell.nix |  .- | hackage.nix |\n| .--------------. |   .----------------.    '-------------'  |  '-------------'\n| | stack-to-nix |---\n | stack-pkgs.nix |-.         |         |         |\n| '--------------' |   '----------------' |         v         |         v\n| .-------------.  |   .----------.       '--\n .----------. \n-'  .--------------.\n| | plan-to-nix |----\n | plan.nix |------.---\n | pkgs.nix | \n--- | stackage.nix |\n| '-------------'  |   '----------'      |     '----------'      '--------------'\n| .--------------. |   .--------------.  |          |\n| | cabal-to-nix |---\n | $package.nix |--'          v\n| '--------------' |   '--------------'       .-------------.\n'------------------'                          | default.nix |\n                                              '-------------'\n                                                    |\n                                                    v\n                                              .-------------.\n                                              | release.nix |\n                                              '-------------'\n\n\n\n\nhaskell.nix diagram\n\n\nnix-tools\n\n\nnix-tools is a Haskell package that provides the following tools:\n\n\n\n\n\n\ncabal-to-nix\n: a \n.cabal\n to \n.nix\n transformer that retains\n  conditional expressions.\n\n\n\n\n\n\nstack-to-nix\n: a \nstack.yaml\n to \n.nix\n transformer that will read\n  in a \nstack.yaml\n expression an generate a \npkgs.nix\n file suited for\n  use with \nhaskell.nix\n.\n\n\n\n\n\n\nplan-to-nix\n: a \nplan.json\n to \n.nix\n transformer that will read in\n  a \nplan.json\n file and generate a \npkgs.nix\n file suited for use\n  with \nhaskell.nix\n.\n\n\n\n\n\n\nas well as a few other tools used to generate \nhackage.nix\n and \nstackage.nix\n.\n\n\nhaskell.nix\n\n\nhaskell.nix is the runtime system for this Haskell infrastructure.  It\ncontains the component builder, as well as the system package and\nlicense mapping.  Without haskell.nix the expressions generated by\neither of the \nnix-tools\n tools make little sense on their own.\n\n\nhackage.nix\n\n\nhackage.nix provides all cabal expressions from hackage as nix\nexpressions.  It is periodically updated to keep in sync with the set\nof packages available on hackage.\n\n\nstackage.nix\n\n\nstackage.nix is similar to hackage.nix but provides all stackage\nsnapshots (lts, and nightly) as nix expressions.  It naturally depends\non hackage.nix to resolve package names, versions and revisions to the\nrepsective packages from hackage.nix.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "There are multiple components that play a part in the haskell.nix\ninfrastructure.  These are  nix-tools ,  haskell.nix ,  hackage.nix ,\nand  stackage.nix .                                               .-------------.     .-------------.\n.- nix-tools ------.                         | haskell.nix |  .- | hackage.nix |\n| .--------------. |   .----------------.    '-------------'  |  '-------------'\n| | stack-to-nix |---  | stack-pkgs.nix |-.         |         |         |\n| '--------------' |   '----------------' |         v         |         v\n| .-------------.  |   .----------.       '--  .----------.  -'  .--------------.\n| | plan-to-nix |----  | plan.nix |------.---  | pkgs.nix |  --- | stackage.nix |\n| '-------------'  |   '----------'      |     '----------'      '--------------'\n| .--------------. |   .--------------.  |          |\n| | cabal-to-nix |---  | $package.nix |--'          v\n| '--------------' |   '--------------'       .-------------.\n'------------------'                          | default.nix |\n                                              '-------------'\n                                                    |\n                                                    v\n                                              .-------------.\n                                              | release.nix |\n                                              '-------------'  haskell.nix diagram", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#nix-tools", 
            "text": "nix-tools is a Haskell package that provides the following tools:    cabal-to-nix : a  .cabal  to  .nix  transformer that retains\n  conditional expressions.    stack-to-nix : a  stack.yaml  to  .nix  transformer that will read\n  in a  stack.yaml  expression an generate a  pkgs.nix  file suited for\n  use with  haskell.nix .    plan-to-nix : a  plan.json  to  .nix  transformer that will read in\n  a  plan.json  file and generate a  pkgs.nix  file suited for use\n  with  haskell.nix .    as well as a few other tools used to generate  hackage.nix  and  stackage.nix .", 
            "title": "nix-tools"
        }, 
        {
            "location": "/architecture/#haskellnix", 
            "text": "haskell.nix is the runtime system for this Haskell infrastructure.  It\ncontains the component builder, as well as the system package and\nlicense mapping.  Without haskell.nix the expressions generated by\neither of the  nix-tools  tools make little sense on their own.", 
            "title": "haskell.nix"
        }, 
        {
            "location": "/architecture/#hackagenix", 
            "text": "hackage.nix provides all cabal expressions from hackage as nix\nexpressions.  It is periodically updated to keep in sync with the set\nof packages available on hackage.", 
            "title": "hackage.nix"
        }, 
        {
            "location": "/architecture/#stackagenix", 
            "text": "stackage.nix is similar to hackage.nix but provides all stackage\nsnapshots (lts, and nightly) as nix expressions.  It naturally depends\non hackage.nix to resolve package names, versions and revisions to the\nrepsective packages from hackage.nix.", 
            "title": "stackage.nix"
        }, 
        {
            "location": "/user-guide/", 
            "text": "User Guide\n\n\nSo you want to use \nhaskell.nix\n with your stack or cabal project. The\ngeneral approach will be to pick the right tool from \nnix-tools\n and\nproduce a \npkgs.nix\n expressions.  Getting a copy of the haskell.nix,\nhackage.nix (and potentially stackage.nix) source will then equip us\nto produce derivations that we can \nnix build\n.\n\n\nSetup\n\n\nThe general structure will be the same for haskell.nix, independent of\nthe use of stack or cabal.  Let us assume for now that we have\ngenerated a \npkgs.nix\n expression in \nnix\n.\n\n\n\n\nGenerating a \npkgs.nix\n for a stack project\n\n\nGenerating a \npkgs.nix\n for a cabal project\n\n\n\n\ndefault.nix\n\n\nWe will start with defining a helper function in our \ndefault.nix\n\nthat will allow us to override the source imports with \n-I\nhaskell=/path/to/haskell.nix\n in case we need it.\n\n\n{ pkgs ? import \nnixpkgs\n {}\n}:\nlet\n  overrideWith = override: default:\n   let\n     try = builtins.tryEval (builtins.findFile builtins.nixPath override);\n   in if try.success then\n     builtins.trace \nusing search host \n${override}\n try.value\n   else\n     default;\nin\n\n\n\n\nNext we will use this to import \nhaskell.nix\n, \nhackage.nix\n and\n\nstackage.nix\n (if we use a stack project).\n\n\nNOTE\n: update the \nrev\n and \nsha256\n values to the recent ones as\n  found on GitHub.  Especially \nhackage.nix\n and \nstackage.nix\n will\n  evolve with package release on hackage and stackage releases\n  respectively.\n\n\nlet\n  # all packages from hackage as nix expressions\n  hackage = import (overrideWith \nhackage\n\n                    (pkgs.fetchFromGitHub { owner  = \ninput-output-hk\n;\n                                            repo   = \nhackage.nix\n;\n                                            rev    = \n3180384b563ec7c7b46bca86b3ace0f32d04cde8\n;\n                                            sha256 = \n19ndkn8pivli9plwq0wnx1cj126l89yk7jw9a0dj51ic3b2qhlb2\n;\n                                            name   = \nhackage-exprs-source\n; }))\n                   ;\n  # a different haskell infrastructure\n  haskell = import (overrideWith \nhaskell\n\n                    (pkgs.fetchFromGitHub { owner  = \ninput-output-hk\n;\n                                            repo   = \nhaskell.nix\n;\n                                            rev    = \n73f733ba8bbd11443dda713d1a2d4b7c50a5d408\n;\n                                            sha256 = \n1p2srrxw2lac5krrg35waa251by98r2miwyg6zac9glpg2vmq3ip\n;\n                                            name   = \nhaskell-lib-source\n; }))\n                   hackage;\n\n  # the set of all stackage snapshots\n  stackage = import (overrideWith \nstackage\n\n                     (pkgs.fetchFromGitHub { owner  = \ninput-output-hk\n;\n                                             repo   = \nstackage.nix\n;\n                                             rev    = \n2615a4e6b1651215ee400e62fcdcb195062a3d35\n;\n                                             sha256 = \n08c8lb8x047hndwm1cb2zxixnjmrswfp5y18xp1v79cjqlva0qj6\n;\n                                             name   = \nstackage-snapshot-source\n; }))\n                   ;\nin\n\n\n\n\nFinally we string this together and produce a package set:\n\n\nlet\n  # Import the file you will create in the stack-to-nix or cabal-to-nix step.\n  my-pkgs = import ./nix/pkgs.nix { inherit stackage; };\n\n  pkgSet = haskell.mkPkgSet {\n    inherit pkgs;\n    pkg-def = my-pkgs.pkg-def;\n    pkg-def-overlays = [\n      # this overlay will provide additional packages\n      # ontop of the package set.  E.g. extra-deps\n      # for stack packages. or local packages for\n      # cabal.projects\n      my-pkgs.overlay\n    ];\n    modules = [\n      # specific package overrides would go here\n      # example:\n      #  packages.cbors.patches = [ ./one.patch ];\n      #  packages.cbors.flags.optimize-gmp = false;\n    ];\n  };\n\nin pkgSet.config.hsPkgs // { _config = pkgSet.config; }\n\n\n\n\nWith this setup you can then start building the components of\ninterest:\n\n\nnix build -f default.nix $pkg.components.library\n\n\n\n\nto build the library for \n$pkg\n or\n\n\nnix build -f default.nix $pkg.components.exes.$exe\n\n\n\n\nto build a specific executable. The same holds for test suites and benchmarks.", 
            "title": "General"
        }, 
        {
            "location": "/user-guide/#user-guide", 
            "text": "So you want to use  haskell.nix  with your stack or cabal project. The\ngeneral approach will be to pick the right tool from  nix-tools  and\nproduce a  pkgs.nix  expressions.  Getting a copy of the haskell.nix,\nhackage.nix (and potentially stackage.nix) source will then equip us\nto produce derivations that we can  nix build .", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#setup", 
            "text": "The general structure will be the same for haskell.nix, independent of\nthe use of stack or cabal.  Let us assume for now that we have\ngenerated a  pkgs.nix  expression in  nix .   Generating a  pkgs.nix  for a stack project  Generating a  pkgs.nix  for a cabal project", 
            "title": "Setup"
        }, 
        {
            "location": "/user-guide/#defaultnix", 
            "text": "We will start with defining a helper function in our  default.nix \nthat will allow us to override the source imports with  -I\nhaskell=/path/to/haskell.nix  in case we need it.  { pkgs ? import  nixpkgs  {}\n}:\nlet\n  overrideWith = override: default:\n   let\n     try = builtins.tryEval (builtins.findFile builtins.nixPath override);\n   in if try.success then\n     builtins.trace  using search host  ${override}  try.value\n   else\n     default;\nin  Next we will use this to import  haskell.nix ,  hackage.nix  and stackage.nix  (if we use a stack project).  NOTE : update the  rev  and  sha256  values to the recent ones as\n  found on GitHub.  Especially  hackage.nix  and  stackage.nix  will\n  evolve with package release on hackage and stackage releases\n  respectively.  let\n  # all packages from hackage as nix expressions\n  hackage = import (overrideWith  hackage \n                    (pkgs.fetchFromGitHub { owner  =  input-output-hk ;\n                                            repo   =  hackage.nix ;\n                                            rev    =  3180384b563ec7c7b46bca86b3ace0f32d04cde8 ;\n                                            sha256 =  19ndkn8pivli9plwq0wnx1cj126l89yk7jw9a0dj51ic3b2qhlb2 ;\n                                            name   =  hackage-exprs-source ; }))\n                   ;\n  # a different haskell infrastructure\n  haskell = import (overrideWith  haskell \n                    (pkgs.fetchFromGitHub { owner  =  input-output-hk ;\n                                            repo   =  haskell.nix ;\n                                            rev    =  73f733ba8bbd11443dda713d1a2d4b7c50a5d408 ;\n                                            sha256 =  1p2srrxw2lac5krrg35waa251by98r2miwyg6zac9glpg2vmq3ip ;\n                                            name   =  haskell-lib-source ; }))\n                   hackage;\n\n  # the set of all stackage snapshots\n  stackage = import (overrideWith  stackage \n                     (pkgs.fetchFromGitHub { owner  =  input-output-hk ;\n                                             repo   =  stackage.nix ;\n                                             rev    =  2615a4e6b1651215ee400e62fcdcb195062a3d35 ;\n                                             sha256 =  08c8lb8x047hndwm1cb2zxixnjmrswfp5y18xp1v79cjqlva0qj6 ;\n                                             name   =  stackage-snapshot-source ; }))\n                   ;\nin  Finally we string this together and produce a package set:  let\n  # Import the file you will create in the stack-to-nix or cabal-to-nix step.\n  my-pkgs = import ./nix/pkgs.nix { inherit stackage; };\n\n  pkgSet = haskell.mkPkgSet {\n    inherit pkgs;\n    pkg-def = my-pkgs.pkg-def;\n    pkg-def-overlays = [\n      # this overlay will provide additional packages\n      # ontop of the package set.  E.g. extra-deps\n      # for stack packages. or local packages for\n      # cabal.projects\n      my-pkgs.overlay\n    ];\n    modules = [\n      # specific package overrides would go here\n      # example:\n      #  packages.cbors.patches = [ ./one.patch ];\n      #  packages.cbors.flags.optimize-gmp = false;\n    ];\n  };\n\nin pkgSet.config.hsPkgs // { _config = pkgSet.config; }  With this setup you can then start building the components of\ninterest:  nix build -f default.nix $pkg.components.library  to build the library for  $pkg  or  nix build -f default.nix $pkg.components.exes.$exe  to build a specific executable. The same holds for test suites and benchmarks.", 
            "title": "default.nix"
        }, 
        {
            "location": "/user-guide-stack/", 
            "text": "User Guide (stack project)\n\n\nHere we will look into how to generate the \npkgs.nix\n file for a\n\nstack.yaml\n project.  For the full integration please see the \nUser\nGuide\n\n\nUsing \nstack-to-nix\n\n\nWith \nnix-tools\n in\n\nPATH\n, we can simply run the following command on a stack project:\n\n\nstack-to-nix -o nix --stack-yaml stack.yaml\n\n\n\n\nThis will produce a \nnix/pkgs.nix\n file that looks like the following:\n\n\n{\n  resolver = \nlts-12.17\n;\n  overlay = hackage:\n    {\n      packages = {\n        \no-clock\n = hackage.o-clock.\n0.1.1\n.revisions.default;\n        ...\n      } // {\n        my-package = ./my-package.nix;\n        ...\n      };\n    };\n}\n\n\n\n\nThis file contains the stackage resolver, as well as an overlay of\npackages.  The overlay specifies which \nextra-deps\n (here: o-clock-0.1.1)\nwe wanted to overlay over the stackage snapshot, and what local\npackages we want (here: my-package).\n\n\nWe will then create the following \nnix/default.nix\n file:\n\n\n{ pkgs ? import \nnixpkgs\n {} }:\n\nlet\n  haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; };\n\n  pkgSet = haskell.mkStackPkgSet {\n    stack-pkgs = import ./pkgs.nix;\n    pkg-def-overlays = [];\n    modules = [];\n  };\n\nin\n  pkgSet.config.hsPkgs\n\n\n\n\nThis generated file is a template, so you can customize it as\nnecessary.\n\n\nIf you came here from the \nUser Guide\n, go back and\n complete the setup.", 
            "title": "Stack Projects"
        }, 
        {
            "location": "/user-guide-stack/#user-guide-stack-project", 
            "text": "Here we will look into how to generate the  pkgs.nix  file for a stack.yaml  project.  For the full integration please see the  User\nGuide", 
            "title": "User Guide (stack project)"
        }, 
        {
            "location": "/user-guide-stack/#using-stack-to-nix", 
            "text": "With  nix-tools  in PATH , we can simply run the following command on a stack project:  stack-to-nix -o nix --stack-yaml stack.yaml  This will produce a  nix/pkgs.nix  file that looks like the following:  {\n  resolver =  lts-12.17 ;\n  overlay = hackage:\n    {\n      packages = {\n         o-clock  = hackage.o-clock. 0.1.1 .revisions.default;\n        ...\n      } // {\n        my-package = ./my-package.nix;\n        ...\n      };\n    };\n}  This file contains the stackage resolver, as well as an overlay of\npackages.  The overlay specifies which  extra-deps  (here: o-clock-0.1.1)\nwe wanted to overlay over the stackage snapshot, and what local\npackages we want (here: my-package).  We will then create the following  nix/default.nix  file:  { pkgs ? import  nixpkgs  {} }:\n\nlet\n  haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; };\n\n  pkgSet = haskell.mkStackPkgSet {\n    stack-pkgs = import ./pkgs.nix;\n    pkg-def-overlays = [];\n    modules = [];\n  };\n\nin\n  pkgSet.config.hsPkgs  This generated file is a template, so you can customize it as\nnecessary.  If you came here from the  User Guide , go back and\n complete the setup.", 
            "title": "Using stack-to-nix"
        }, 
        {
            "location": "/user-guide-cabal/", 
            "text": "User Guide (cabal project)\n\n\nHere we will look into how to generate the \npkgs.nix\n file for a\n\ncabal.project\n project.  For the full integration please see the \nUser\nGuide\n\n\nUsing \nplan-to-nix\n\n\nWe currently don't have a \nproject-to-nix\n tool yet, as such creating\n the relevant \npkgs.nix\n file for a \ncabal.project\n is slightly more\n involved than for a corresponding stack project\n.\n\n\nWith \nnix-tools\n in\n\nPATH\n, we can simply run the following command on a cabal package:\n\n\n# make sure the cabal project is configured (the plan.json file is generated)\ncabal new-configure\n# convert the plan.json file into a pkgs.nix file\nplan-to-nix dist-newstyle/cache/plan.json \n nix/plan.nix\n\n\n\n\nThis will produce a \nnix/plan.nix\n file that looks like the following:\n\n\nhackage:\n  {\n    packages = {\n      \no-clock\n = hackage.o-clock.\n0.1.1\n.revisions.default;\n      ...\n    };\n    compiler = { ... };\n  }\n\n\n\n\nit specifically does not include any of our local packages yet. We\nwill need to run\n\n\ncabal-to-nix $path \n nix/$pkg.nix\n\n\n\n\nor\n\n\ncabal-to-nix $url $rev \n nix/$pkg.nix\n\n\n\n\nfor each local (or source) package.\n\n\nWith this in place we can then proceed to build the \nnix/pkgs.nix\n\nfile as follows:\n\n\nlet plan = import ./plan.nix; in\n{ ... }:\n{ pkg-def = plan;\n  overlay =\n    { local-package-a = ./local-package-a.nix;\n      local-package-b = ./local-package-b.nix;\n      source-import-a = ./source-import-a.nix;\n      source-import-b = ./source-import-b.nix;\n      ...\n    };\n}\n\n\n\n\nIf you came here from the \nUser Guide\n, go back and\n complete the setup.", 
            "title": "Cabal Proejcts"
        }, 
        {
            "location": "/user-guide-cabal/#user-guide-cabal-project", 
            "text": "Here we will look into how to generate the  pkgs.nix  file for a cabal.project  project.  For the full integration please see the  User\nGuide", 
            "title": "User Guide (cabal project)"
        }, 
        {
            "location": "/user-guide-cabal/#using-plan-to-nix", 
            "text": "We currently don't have a  project-to-nix  tool yet, as such creating\n the relevant  pkgs.nix  file for a  cabal.project  is slightly more\n involved than for a corresponding stack project .  With  nix-tools  in PATH , we can simply run the following command on a cabal package:  # make sure the cabal project is configured (the plan.json file is generated)\ncabal new-configure\n# convert the plan.json file into a pkgs.nix file\nplan-to-nix dist-newstyle/cache/plan.json   nix/plan.nix  This will produce a  nix/plan.nix  file that looks like the following:  hackage:\n  {\n    packages = {\n       o-clock  = hackage.o-clock. 0.1.1 .revisions.default;\n      ...\n    };\n    compiler = { ... };\n  }  it specifically does not include any of our local packages yet. We\nwill need to run  cabal-to-nix $path   nix/$pkg.nix  or  cabal-to-nix $url $rev   nix/$pkg.nix  for each local (or source) package.  With this in place we can then proceed to build the  nix/pkgs.nix \nfile as follows:  let plan = import ./plan.nix; in\n{ ... }:\n{ pkg-def = plan;\n  overlay =\n    { local-package-a = ./local-package-a.nix;\n      local-package-b = ./local-package-b.nix;\n      source-import-a = ./source-import-a.nix;\n      source-import-b = ./source-import-b.nix;\n      ...\n    };\n}  If you came here from the  User Guide , go back and\n complete the setup.", 
            "title": "Using plan-to-nix"
        }, 
        {
            "location": "/iohk-nix/", 
            "text": "IOHK's nix tooling\n\n\niohk-nix\n\n\niohk-nix is IOHK's shared nix library.  It provides some templates to\nmake working with haskell.nix trivial but is non-essential to use\nhaskell.nix infrastructure.\n\n\nlib.nix\n\n\nlet\n  # iohk-nix can be overridden for debugging purposes by setting\n  # NIX_PATH=iohk_nix=/path/to/iohk-nix\n  iohkNix = import (\n    let try = builtins.tryEval \niohk_nix\n;\n    in if try.success\n    then builtins.trace \nusing host \niohk_nix\n try.value\n    else\n      let\n        spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json);\n      in builtins.fetchTarball {\n        url = \n${spec.url}/archive/${spec.rev}.tar.gz\n;\n        inherit (spec) sha256;\n      }) {};\n\n  pkgs = iohkNix.pkgs;\n  lib = pkgs.lib;\nin lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; }\n\n\n\n\niohk-nix.json\n\n\n{\n  \nurl\n: \nhttps://github.com/input-output-hk/iohk-nix\n,\n  \nrev\n: \nc92f0119ef5814b0ed1f445c2fdcf8894e326294\n,\n  \nsha256\n: \n05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm\n,\n  \nfetchSubmodules\n: false\n}\n\n\n\n\nnix/pkgs.nix\n\n\n{ pkgs ? import \nnixpkgs\n {}\n, iohk-overlay ? {}\n, iohk-module ? {}\n, haskell\n, hackage\n, stackage\n, ...\n}:\nlet\n  # our packages\n  stack-pkgs = import ./.stack-pkgs.nix;\n\n  # packages which will require TH and thus\n  # will need -fexternal-interpreter treatment\n  # when cross compiling.\n  th-packages = [\n    \nhedgehog\n \ncardano-crypto-wrapper\n\n    \ncardano-crypto-test\n \ncardano-chain\n\n    \nsmall-steps\n \ncs-ledger\n ];\n\n  # Build the packageset with module support.\n  # We can essentially override anything in the modules\n  # section.\n  #\n  #  packages.cbors.patches = [ ./one.patch ];\n  #  packages.cbors.flags.optimize-gmp = false;\n  #\n  compiler = (stack-pkgs.overlay hackage).compiler.nix-name;\n  pkgSet = haskell.mkNewPkgSet {\n    inherit pkgs;\n    pkg-def = stackage.${stack-pkgs.resolver};\n    # The overlay allows extension or restriction of the set of\n    # packages we are interested in. By using the stack-pkgs.overlay\n    # we restrict our package set to the ones provided in stack.yaml.\n    pkg-def-overlays = [\n      stack-pkgs.overlay\n      iohk-overlay.${compiler}\n    ];\n    # package customizations\n    modules = [\n      # This module will ensure that we get the necessary\n      # patches ontop of GHC packages that for which the\n      # ones that GHC ships are not identical to the ones\n      # we find on hackage. These patches will make sure\n      # they are identical by augmenting the packages on\n      # hackage to match those that ship with ghc.\n      haskell.ghcHackagePatches.${compiler}\n\n      # the iohk-module will supply us with the necessary\n      # cross compilation plumbing to make Template Haskell\n      # work when cross compiling.  For now we need to\n      # list the packages that require template haskell\n      # explicity here.\n      (iohk-module { nixpkgs = pkgs;\n                     inherit th-packages; })\n    ];\n  };\nin\n  pkgSet.config.hsPkgs // { _config = pkgSet.config; }\n\n\n\n\ndefault.nix\n\n\nlet\n  localLib = import ./lib.nix;\nin\n# This file needs to export a function that takes\n# the arguments it is passed and forwards them to\n# the default-nix template from iohk-nix. This is\n# important so that the release.nix file can properly\n# parameterize this file when targetting different\n# hosts.\n{ ... }@args:\n# We will instantiate the defaul-nix template with the\n# nix/pkgs.nix file...\nlocalLib.nix-tools.default-nix ./nix/pkgs.nix args\n# ... and add a few custom packages as well.\n// { }", 
            "title": "IOHKs nix library"
        }, 
        {
            "location": "/iohk-nix/#iohks-nix-tooling", 
            "text": "", 
            "title": "IOHK's nix tooling"
        }, 
        {
            "location": "/iohk-nix/#iohk-nix", 
            "text": "iohk-nix is IOHK's shared nix library.  It provides some templates to\nmake working with haskell.nix trivial but is non-essential to use\nhaskell.nix infrastructure.  lib.nix  let\n  # iohk-nix can be overridden for debugging purposes by setting\n  # NIX_PATH=iohk_nix=/path/to/iohk-nix\n  iohkNix = import (\n    let try = builtins.tryEval  iohk_nix ;\n    in if try.success\n    then builtins.trace  using host  iohk_nix  try.value\n    else\n      let\n        spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json);\n      in builtins.fetchTarball {\n        url =  ${spec.url}/archive/${spec.rev}.tar.gz ;\n        inherit (spec) sha256;\n      }) {};\n\n  pkgs = iohkNix.pkgs;\n  lib = pkgs.lib;\nin lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; }  iohk-nix.json  {\n   url :  https://github.com/input-output-hk/iohk-nix ,\n   rev :  c92f0119ef5814b0ed1f445c2fdcf8894e326294 ,\n   sha256 :  05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm ,\n   fetchSubmodules : false\n}  nix/pkgs.nix  { pkgs ? import  nixpkgs  {}\n, iohk-overlay ? {}\n, iohk-module ? {}\n, haskell\n, hackage\n, stackage\n, ...\n}:\nlet\n  # our packages\n  stack-pkgs = import ./.stack-pkgs.nix;\n\n  # packages which will require TH and thus\n  # will need -fexternal-interpreter treatment\n  # when cross compiling.\n  th-packages = [\n     hedgehog   cardano-crypto-wrapper \n     cardano-crypto-test   cardano-chain \n     small-steps   cs-ledger  ];\n\n  # Build the packageset with module support.\n  # We can essentially override anything in the modules\n  # section.\n  #\n  #  packages.cbors.patches = [ ./one.patch ];\n  #  packages.cbors.flags.optimize-gmp = false;\n  #\n  compiler = (stack-pkgs.overlay hackage).compiler.nix-name;\n  pkgSet = haskell.mkNewPkgSet {\n    inherit pkgs;\n    pkg-def = stackage.${stack-pkgs.resolver};\n    # The overlay allows extension or restriction of the set of\n    # packages we are interested in. By using the stack-pkgs.overlay\n    # we restrict our package set to the ones provided in stack.yaml.\n    pkg-def-overlays = [\n      stack-pkgs.overlay\n      iohk-overlay.${compiler}\n    ];\n    # package customizations\n    modules = [\n      # This module will ensure that we get the necessary\n      # patches ontop of GHC packages that for which the\n      # ones that GHC ships are not identical to the ones\n      # we find on hackage. These patches will make sure\n      # they are identical by augmenting the packages on\n      # hackage to match those that ship with ghc.\n      haskell.ghcHackagePatches.${compiler}\n\n      # the iohk-module will supply us with the necessary\n      # cross compilation plumbing to make Template Haskell\n      # work when cross compiling.  For now we need to\n      # list the packages that require template haskell\n      # explicity here.\n      (iohk-module { nixpkgs = pkgs;\n                     inherit th-packages; })\n    ];\n  };\nin\n  pkgSet.config.hsPkgs // { _config = pkgSet.config; }  default.nix  let\n  localLib = import ./lib.nix;\nin\n# This file needs to export a function that takes\n# the arguments it is passed and forwards them to\n# the default-nix template from iohk-nix. This is\n# important so that the release.nix file can properly\n# parameterize this file when targetting different\n# hosts.\n{ ... }@args:\n# We will instantiate the defaul-nix template with the\n# nix/pkgs.nix file...\nlocalLib.nix-tools.default-nix ./nix/pkgs.nix args\n# ... and add a few custom packages as well.\n// { }", 
            "title": "iohk-nix"
        }, 
        {
            "location": "/dev-architecture/", 
            "text": "Developer Architecture Overview\n\n\nThis shall give a sufficiently good overview over the haskell.nix\nideas, such that a new developer can navigate around without too\nmuch trouble.\n\n\nPackages\n\n\nhaskell.nix\n is centered around packages (haskell package\ndescriptions as nix-expressions). These are generated by\n\ncabal-to-nix\n from the \nnix-tools\n package. \nstack-to-nix\n and\n\nplan-to-nix\n will delegate the transformation of cabal packages to\nnix expressions to the same code that \ncabal-to-nix\n uses.\n\n\nThese packages will look similar to the following:\n\n\n{ system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }:\n{\n  flags = {};\n  package = { ... };\n  components = {\n    \nlibrary\n = { depends = [ ... ]; };\n    exes = { \n...\n = { depends = [ ... ]; }; ... };\n    sublibs = { \n...\n = { depends = [ ... ]; }; ... };\n    tests = { \n...\n = { depends = [ ... ]; }; ... };\n    benchmarks = { \n...\n = { depends = [ ... ]; }; ... };\n  };\n};\n\n\n\n\nThe exact specification can be found in \nmodules/package.nix\n.\n\n\nPlans\n\n\nPackages (unless specified directly in the \npackages\n attribute of the\nmodule) usually come from a plan. A plan is either a Stackage snapshot\n(nightly or LTS) or a build plan as produced by \ncabal\n.\n\n\nPlan files usually look like the following:\n\n\nhackage:\n{\n  packages = {\n    \n$pkg\n.revision = hackage.$pkg.$version.revisions.default;\n    \n$pkg\n.flags = { flag1 = true; flag2 = false; ... };\n    ...\n  };\n  compiler = {\n    version = \n8.4.4\n;\n      nix-name = \nghc844\n;\n      packages = {\n        \nbinary\n = \n0.8.5.1\n;\n    ...\n      };\n   };\n}\n\n\n\n\nThis provides enough information about the compiler, what packages the\ncompiler ships with and the packages we want to use in our plan.\n\n\nThis revision and flag information will be inlined into a list of\npackages in \nconfig.packages\n in \nmodules/plan.nix\n.  Thus\n\nconfig.packages\n will only contains packages as described in the\nprevious section.\n\n\nPackage Sets (of derivations)\n\n\nWe finally tie this all together in \npackage-set.nix\n where we use\n\nmodules/component-driver.nix\n to produce the derivations for each\npackages component to produce the final \nconfig.hsPkgs\n value.\n\n\nThere is also a \nmodules/compat-driver.nix\n that should produce the\nsame packageset to be used with the stock haskell infrastructure in\nnixpkgs (\nThis has undergone substantially less testing\n).\n\n\nComponent builder\n\n\nTo prevent depending on mutliple instances of the same libraries, the\ncomponent builder will try to build every package from scratch and\nrely as little as possible on packages that are shipped with the GHC\ndistribution. The exceptions are packages that are known to not be\nreinstallable. See \nconfig.nonReinstallablePkgs\n.\n\n\nThe component builder can be found in \nmodules/component-driver.nix\n\nand \nbuilder/default.nix\n. The component-driver will ensure that we do\nnot try to rebuild non-reinstallable packages, and call the\n\nbuilder/default.nix\n on each package in \nconfig.packages\n to produce\n\nconfig.hsPkgs\n.", 
            "title": "Architecture"
        }, 
        {
            "location": "/dev-architecture/#developer-architecture-overview", 
            "text": "This shall give a sufficiently good overview over the haskell.nix\nideas, such that a new developer can navigate around without too\nmuch trouble.", 
            "title": "Developer Architecture Overview"
        }, 
        {
            "location": "/dev-architecture/#packages", 
            "text": "haskell.nix  is centered around packages (haskell package\ndescriptions as nix-expressions). These are generated by cabal-to-nix  from the  nix-tools  package.  stack-to-nix  and plan-to-nix  will delegate the transformation of cabal packages to\nnix expressions to the same code that  cabal-to-nix  uses.  These packages will look similar to the following:  { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }:\n{\n  flags = {};\n  package = { ... };\n  components = {\n     library  = { depends = [ ... ]; };\n    exes = {  ...  = { depends = [ ... ]; }; ... };\n    sublibs = {  ...  = { depends = [ ... ]; }; ... };\n    tests = {  ...  = { depends = [ ... ]; }; ... };\n    benchmarks = {  ...  = { depends = [ ... ]; }; ... };\n  };\n};  The exact specification can be found in  modules/package.nix .", 
            "title": "Packages"
        }, 
        {
            "location": "/dev-architecture/#plans", 
            "text": "Packages (unless specified directly in the  packages  attribute of the\nmodule) usually come from a plan. A plan is either a Stackage snapshot\n(nightly or LTS) or a build plan as produced by  cabal .  Plan files usually look like the following:  hackage:\n{\n  packages = {\n     $pkg .revision = hackage.$pkg.$version.revisions.default;\n     $pkg .flags = { flag1 = true; flag2 = false; ... };\n    ...\n  };\n  compiler = {\n    version =  8.4.4 ;\n      nix-name =  ghc844 ;\n      packages = {\n         binary  =  0.8.5.1 ;\n    ...\n      };\n   };\n}  This provides enough information about the compiler, what packages the\ncompiler ships with and the packages we want to use in our plan.  This revision and flag information will be inlined into a list of\npackages in  config.packages  in  modules/plan.nix .  Thus config.packages  will only contains packages as described in the\nprevious section.", 
            "title": "Plans"
        }, 
        {
            "location": "/dev-architecture/#package-sets-of-derivations", 
            "text": "We finally tie this all together in  package-set.nix  where we use modules/component-driver.nix  to produce the derivations for each\npackages component to produce the final  config.hsPkgs  value.  There is also a  modules/compat-driver.nix  that should produce the\nsame packageset to be used with the stock haskell infrastructure in\nnixpkgs ( This has undergone substantially less testing ).", 
            "title": "Package Sets (of derivations)"
        }, 
        {
            "location": "/dev-architecture/#component-builder", 
            "text": "To prevent depending on mutliple instances of the same libraries, the\ncomponent builder will try to build every package from scratch and\nrely as little as possible on packages that are shipped with the GHC\ndistribution. The exceptions are packages that are known to not be\nreinstallable. See  config.nonReinstallablePkgs .  The component builder can be found in  modules/component-driver.nix \nand  builder/default.nix . The component-driver will ensure that we do\nnot try to rebuild non-reinstallable packages, and call the builder/default.nix  on each package in  config.packages  to produce config.hsPkgs .", 
            "title": "Component builder"
        }, 
        {
            "location": "/removing-with-package-wrapper/", 
            "text": "ghcWithPackages\n wrapper removal\n\n\nThe current \nNixpkgs Haskell infrastructure\n and \nhaskell.nix\n both\nprovide a \nghcWithPackages\n derivation which contains shell script\nwrappers that wrap \nghc\n and \nghc-pkg\n.\n\n\nIn the Nixpkgs Haskell infrastructure, the wrapper scripts are used\nfor building Haskell packages. However, in \nhaskell.nix\n, the wrappers\nare only used for development environments.\n\n\nThe wrapper scripts provide a \nghc\n command that \"knows\" about the\npackage set and has all Haskell package dependencies available to it.\n\n\nWe would like to remove the wrapper scripts, but it's currently not\npossible to configure all build tools using environment variables\nalone.\n\n\nPlain \nghc\n\n\nWhen using \nghc\n or \nghci\n by itself, the \nGHC_ENVIRONMENT\n variable\ncan point to a configuration file containing an exact package\nset. This works quite well.\n\n\nghc-pkg\n\n\nThe package tool \nghc-pkg\n does not recognize \nGHC_ENVIRONMENT\n, but\ndoes recognize a \nGHC_PACKAGE_PATH\n pointing to a \npackage.conf.d\n.\n\n\nThis works well. However, the \ncabal\n command will refuse to start if\n\nGHC_PACKAGE_PATH\n is set.\n\n\nSetup.hs\n\n\nWhen invoking \nSetup.hs configure\n, the package database is provided\nwith the \n--package-db\n argument and exact dependencies in the package\nset can be provided as \n--dependency\n arguments.\n\n\nThe \nhaskell.nix\n component builder uses \nSetup.hs\n with these\ncommand-line options to build Haskell packages.\n\n\ncabal new-build\n\n\nCabal-install will observe the \nCABAL_CONFIG\n environment variable,\nwhich points to a cabal config file. This config file can provide a\n\npackage-db\n value, but it can't specify exact versions of packages.\n\n\nCabal is designed to solve dependencies, not simply take the package\nset which is given to it.\n\n\nTherefore, \ncabal\n does not use \nGHC_ENVIRONMENT\n, but instead creates\nits own environment file. It will not accept \n--dependency\n arguments.\n\n\nAs far as I know, the best way to force \ncabal\n to take a pre-computed\npackage set is to use a \nnew-freeze\n file. However there is no\nenvironment variable (or config file entry) which can specify a path\nto a freeze file.\n\n\nSpecifying a \npackage-db\n path in the cabal config file is not enough\nfor it to successfully resolve dependencies.\n\n\nAs mentioned before, \ncabal\n does not work when \nGHC_PACKAGE_PATH\n is\nset. The best way to work around this is to wrap \nghc\n and \nghc-pkg\n\nin shell scripts.", 
            "title": "Removing withPackage wrapper"
        }, 
        {
            "location": "/removing-with-package-wrapper/#ghcwithpackages-wrapper-removal", 
            "text": "The current  Nixpkgs Haskell infrastructure  and  haskell.nix  both\nprovide a  ghcWithPackages  derivation which contains shell script\nwrappers that wrap  ghc  and  ghc-pkg .  In the Nixpkgs Haskell infrastructure, the wrapper scripts are used\nfor building Haskell packages. However, in  haskell.nix , the wrappers\nare only used for development environments.  The wrapper scripts provide a  ghc  command that \"knows\" about the\npackage set and has all Haskell package dependencies available to it.  We would like to remove the wrapper scripts, but it's currently not\npossible to configure all build tools using environment variables\nalone.", 
            "title": "ghcWithPackages wrapper removal"
        }, 
        {
            "location": "/removing-with-package-wrapper/#plain-ghc", 
            "text": "When using  ghc  or  ghci  by itself, the  GHC_ENVIRONMENT  variable\ncan point to a configuration file containing an exact package\nset. This works quite well.", 
            "title": "Plain ghc"
        }, 
        {
            "location": "/removing-with-package-wrapper/#ghc-pkg", 
            "text": "The package tool  ghc-pkg  does not recognize  GHC_ENVIRONMENT , but\ndoes recognize a  GHC_PACKAGE_PATH  pointing to a  package.conf.d .  This works well. However, the  cabal  command will refuse to start if GHC_PACKAGE_PATH  is set.", 
            "title": "ghc-pkg"
        }, 
        {
            "location": "/removing-with-package-wrapper/#setuphs", 
            "text": "When invoking  Setup.hs configure , the package database is provided\nwith the  --package-db  argument and exact dependencies in the package\nset can be provided as  --dependency  arguments.  The  haskell.nix  component builder uses  Setup.hs  with these\ncommand-line options to build Haskell packages.", 
            "title": "Setup.hs"
        }, 
        {
            "location": "/removing-with-package-wrapper/#cabal-new-build", 
            "text": "Cabal-install will observe the  CABAL_CONFIG  environment variable,\nwhich points to a cabal config file. This config file can provide a package-db  value, but it can't specify exact versions of packages.  Cabal is designed to solve dependencies, not simply take the package\nset which is given to it.  Therefore,  cabal  does not use  GHC_ENVIRONMENT , but instead creates\nits own environment file. It will not accept  --dependency  arguments.  As far as I know, the best way to force  cabal  to take a pre-computed\npackage set is to use a  new-freeze  file. However there is no\nenvironment variable (or config file entry) which can specify a path\nto a freeze file.  Specifying a  package-db  path in the cabal config file is not enough\nfor it to successfully resolve dependencies.  As mentioned before,  cabal  does not work when  GHC_PACKAGE_PATH  is\nset. The best way to work around this is to wrap  ghc  and  ghc-pkg \nin shell scripts.", 
            "title": "cabal new-build"
        }, 
        {
            "location": "/maintainer-scripts/", 
            "text": "Updating Hackage and Stackage Nix expressions\n\n\nThe \nhackage.nix\n\nand \nstackage.nix\n\nrepos and corresponding files \nhackage-src.json\n and\n\nstackage-src.json\n will be regularly and automatically updated using\nscripts in this repo.\n\n\nTo run the updater scripts manually, use:\n\n\nnix-build -A maintainer-scripts.update-hackage -o update-hackage.sh\n./update-hackage.sh\n\nnix-build -A maintainer-scripts.update-stackage -o update-stackage.sh\n./update-stackage.sh\n\n\n\nThe scripts will clone the repo, generate the latest data, then\nattempt to push back to the repo and update the source JSON file.", 
            "title": "Maintainer Scripts"
        }, 
        {
            "location": "/maintainer-scripts/#updating-hackage-and-stackage-nix-expressions", 
            "text": "The  hackage.nix \nand  stackage.nix \nrepos and corresponding files  hackage-src.json  and stackage-src.json  will be regularly and automatically updated using\nscripts in this repo.  To run the updater scripts manually, use:  nix-build -A maintainer-scripts.update-hackage -o update-hackage.sh\n./update-hackage.sh\n\nnix-build -A maintainer-scripts.update-stackage -o update-stackage.sh\n./update-stackage.sh  The scripts will clone the repo, generate the latest data, then\nattempt to push back to the repo and update the source JSON file.", 
            "title": "Updating Hackage and Stackage Nix expressions"
        }
    ]
}