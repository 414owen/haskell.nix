{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"haskell.nix haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison. Motivation Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs cross compilation nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time. package sets We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides it's own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set. component level control The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue. cyclic dependencies The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components. build times The Haskell builder in nixpkgs build package sequentially, first the library than the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized you build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum. more logic in nix The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date. decoupling Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Introduction"},{"location":"#haskellnix","text":"haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison.","title":"haskell.nix"},{"location":"#motivation","text":"Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs","title":"Motivation"},{"location":"#cross-compilation","text":"nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time.","title":"cross compilation"},{"location":"#package-sets","text":"We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides it's own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set.","title":"package sets"},{"location":"#component-level-control","text":"The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue.","title":"component level control"},{"location":"#cyclic-dependencies","text":"The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.","title":"cyclic dependencies"},{"location":"#build-times","text":"The Haskell builder in nixpkgs build package sequentially, first the library than the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized you build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum.","title":"build times"},{"location":"#more-logic-in-nix","text":"The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date.","title":"more logic in nix"},{"location":"#decoupling","text":"Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"decoupling"},{"location":"architecture/","text":"Architecture There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram nix-tools nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix . haskell.nix Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own. hackage.nix hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage. stackage.nix stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram","title":"Architecture"},{"location":"architecture/#nix-tools","text":"nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix .","title":"nix-tools"},{"location":"architecture/#haskellnix","text":"Haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own.","title":"haskell.nix"},{"location":"architecture/#hackagenix","text":"hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage.","title":"hackage.nix"},{"location":"architecture/#stackagenix","text":"stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"stackage.nix"},{"location":"changelog/","text":"This file contains a summary of changes to Haskell.nix and nix-tools that will impact users. June 7, 2019 Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages. May 29, 2019 Added shellFor function to package set. May 28, 2019 Added snaphots and haskellPackages attributes to the Haskell.nix top-level. May 22, 2019 Add the cleanSourceHaskell utility function to the Haskell.nix top-level. May 21, 2019 Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo. May 20, 2019 Remove Travis CI in favour of Buildkite. May 17, 2019 Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually. Mar 15, 2019 overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"ChangeLog"},{"location":"changelog/#june-7-2019","text":"Several additions to the documentation . More information about getting nix-tools, Haskell.nix, pinning. Updates the stack-to-nix and cabal-to-nix guides. Adds a section on development environments. Adds a little information about cross compilation. Adds a (partially complete) reference section (command line manuals, library reference). Symlinks the changelog into the documentation pages.","title":"June 7, 2019"},{"location":"changelog/#may-29-2019","text":"Added shellFor function to package set.","title":"May 29, 2019"},{"location":"changelog/#may-28-2019","text":"Added snaphots and haskellPackages attributes to the Haskell.nix top-level.","title":"May 28, 2019"},{"location":"changelog/#may-22-2019","text":"Add the cleanSourceHaskell utility function to the Haskell.nix top-level.","title":"May 22, 2019"},{"location":"changelog/#may-21-2019","text":"Add the callCabalProjectToNix function, which uses \"import from derivation\" (IFD) so that nix-tools doesn't need to be run manually. The hackage.nix update process has changed, so that Cabal index state hashes are also included in the generated repo.","title":"May 21, 2019"},{"location":"changelog/#may-20-2019","text":"Remove Travis CI in favour of Buildkite.","title":"May 20, 2019"},{"location":"changelog/#may-17-2019","text":"Add the callStackToNix function, which uses \"import from derivation\" (IFD) so that stack-to-nix doesn't need to be run manually.","title":"May 17, 2019"},{"location":"changelog/#mar-15-2019","text":"overlays was renamed to extras in #79 to prevent confusion between the notion of Nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"Mar 15, 2019"},{"location":"dev-architecture/","text":"Developer Architecture Overview This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble. Packages haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix . Plans Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section. Package Sets (of derivations) We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ). Component builder To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Architecture"},{"location":"dev-architecture/#developer-architecture-overview","text":"This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble.","title":"Developer Architecture Overview"},{"location":"dev-architecture/#packages","text":"haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix .","title":"Packages"},{"location":"dev-architecture/#plans","text":"Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section.","title":"Plans"},{"location":"dev-architecture/#package-sets-of-derivations","text":"We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ).","title":"Package Sets (of derivations)"},{"location":"dev-architecture/#component-builder","text":"To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Component builder"},{"location":"iohk-nix/","text":"IOHK's nix tooling iohk-nix iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"IOHKs nix library"},{"location":"iohk-nix/#iohks-nix-tooling","text":"","title":"IOHK's nix tooling"},{"location":"iohk-nix/#iohk-nix","text":"iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"iohk-nix"},{"location":"maintainer-scripts/","text":"Updating Hackage and Stackage Nix expressions The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Maintainer Scripts"},{"location":"maintainer-scripts/#updating-hackage-and-stackage-nix-expressions","text":"The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build build.nix -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build build.nix -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Updating Hackage and Stackage Nix expressions"},{"location":"removing-with-package-wrapper/","text":"ghcWithPackages wrapper removal The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone. Plain ghc When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well. ghc-pkg The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set. Setup.hs When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages. cabal new-build Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"Removing withPackage wrapper"},{"location":"removing-with-package-wrapper/#ghcwithpackages-wrapper-removal","text":"The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone.","title":"ghcWithPackages wrapper removal"},{"location":"removing-with-package-wrapper/#plain-ghc","text":"When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well.","title":"Plain ghc"},{"location":"removing-with-package-wrapper/#ghc-pkg","text":"The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set.","title":"ghc-pkg"},{"location":"removing-with-package-wrapper/#setuphs","text":"When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages.","title":"Setup.hs"},{"location":"removing-with-package-wrapper/#cabal-new-build","text":"Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"cabal new-build"},{"location":"user-guide/","text":"User Guide So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build . Installing nix-tools To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt Getting the Haskell.nix source (optional) The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . nix-tools --out-link nt Importing Haskell.nix into your project The easiest way to get a hold of Haskell.nix is with fetchTarball . import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {} If you have your own pkgs variable, pass it to Haskell.nix to prevent double-evaluation of the Nixpkgs collection. { pkgs ? import nixpkgs {} }: import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; } Pinning the Haskell.nix version For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { url : https://github.com/input-output-hk/haskell.nix , rev : f1a94a4c82a2ab999a67c3b84269da78d89f0075 , date : 2019-06-05T01:06:12+00:00 , sha256 : 0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla , fetchSubmodules : false } (The tee command is just to show you the result.) Use the following expression to import that version: { pkgs ? import nixpkgs {} }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = pkgs.fetchgit { name = haskell-lib ; inherit (spec) url rev sha256 fetchSubmodules; }; in import haskell-nix-src { inherit pkgs; } There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal. Overriding the Hackage version Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import nixpkgs {} }: import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; } Using nix repl It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { pkgs ? import nixpkgs {} }: rec { haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; pkgNames = pkgs.lib.attrNames haskell.snapshots. lts-13.18 ; } Load the example file: $ nix repl ' nixpkgs ' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading ' nixpkgs '... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl lib.take 5 pkgNames [ ALUT ANum Allure Boolean BoundedChan ] nix-repl Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"General"},{"location":"user-guide/#user-guide","text":"So you want to use Haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expression. Getting a copy of the nix-tools (and potentially the Haskell.nix source), will then equip us to produce derivations that we can nix build .","title":"User Guide"},{"location":"user-guide/#installing-nix-tools","text":"To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt","title":"Installing nix-tools"},{"location":"user-guide/#getting-the-haskellnix-source-optional","text":"The Haskell.nix and nix-tools source will be useful if you would like to contribute improvements, or read the source code to fully understand something that the documentation doesn't cover. git clone https://github.com/input-output-hk/nix-tools git clone https://github.com/input-output-hk/haskell.nix cd haskell.nix nix build -f . nix-tools --out-link nt","title":"Getting the Haskell.nix source (optional)"},{"location":"user-guide/#importing-haskellnix-into-your-project","text":"The easiest way to get a hold of Haskell.nix is with fetchTarball . import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {} If you have your own pkgs variable, pass it to Haskell.nix to prevent double-evaluation of the Nixpkgs collection. { pkgs ? import nixpkgs {} }: import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }","title":"Importing Haskell.nix into your project"},{"location":"user-guide/#pinning-the-haskellnix-version","text":"For simplicity's sake we will use fetchTarball for the examples in this documentation. This will always get the latest version, and is similar to an auto-updating Nix channel. However, in your own project, you may wish to pin Haskell.nix (as you would pin Nixpkgs). This will make your builds reproducable, more predictable, and faster (because the fixed version is cached). One way of doing this is to use nix-prefetch-git to get a JSON file with a revision and SHA-256 hash of Haskell.nix . $ nix-prefetch-git --quiet https://github.com/input-output-hk/haskell.nix | tee haskell-nix-src.json { url : https://github.com/input-output-hk/haskell.nix , rev : f1a94a4c82a2ab999a67c3b84269da78d89f0075 , date : 2019-06-05T01:06:12+00:00 , sha256 : 0ggxsppjlb6q6a83y12cwgrdnqnw1s128rpibgzs5p1966bdfqla , fetchSubmodules : false } (The tee command is just to show you the result.) Use the following expression to import that version: { pkgs ? import nixpkgs {} }: let spec = builtins.fromJSON (builtins.readFile ./haskell-nix-src.json); haskell-nix-src = pkgs.fetchgit { name = haskell-lib ; inherit (spec) url rev sha256 fetchSubmodules; }; in import haskell-nix-src { inherit pkgs; } There are other possible schemes for pinning. See haskell.nix/lib/fetch-external.nix , the niv tool, or the Nix Flakes proposal.","title":"Pinning the Haskell.nix version"},{"location":"user-guide/#overriding-the-hackage-version","text":"Sometimes you might want to use a chosen version of Haskell.nix with a recent update of Hackage or Stackage. This can be done with JSON pins: nix-prefetch-git https://github.com/input-output-hk/hackage.nix | tee hackage-src.json nix-prefetch-git https://github.com/input-output-hk/stackage.nix | tee stackage-src.json The resulting JSON files will correspond to the latest revision of hackage.nix and stackage.nix . See Architecture for more information about how these Git repositories correspond to the actual Hackage and Stackage. { pkgs ? import nixpkgs {} }: import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; hackageSourceJSON = ./hackage-src.json; stackageSourceJSON = ./stackage-src.json; }","title":"Overriding the Hackage version"},{"location":"user-guide/#using-nix-repl","text":"It's sometimes useful to load Haskell.nix in the REPL to explore attrsets and try examples. # example.nix { pkgs ? import nixpkgs {} }: rec { haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) { inherit pkgs; }; pkgNames = pkgs.lib.attrNames haskell.snapshots. lts-13.18 ; } Load the example file: $ nix repl ' nixpkgs ' example.nix Welcome to Nix version 2.3pre6631_e58a7144. Type :? for help. Loading ' nixpkgs '... Added 10403 variables. Loading 'example2.nix'... Added 2 variables. nix-repl lib.take 5 pkgNames [ ALUT ANum Allure Boolean BoundedChan ] nix-repl Now that you have nix-tools and are able to import Haskell.nix , you can continue to the next chapter.","title":"Using nix repl"},{"location":"reference/commands/","text":"stack-to-nix stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: stack.yaml ) --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: .stack-to-nix.cache ) -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache . (There's an open issue for this). plan-to-nix plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: dist-newstyle/cache/plan.json ) --cabal-project FILE Override path to cabal.project (default: cabal.project ) --cache FILE Dependency cache file (default: .nix-tools.cache ) -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Same note as above applies about the cache file. cabal-to-nix Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"Command-line tools"},{"location":"reference/commands/#stack-to-nix","text":"stack-to-nix - a stack to nix converter Usage: stack-to-nix (-o|--output DIR) [--stack-yaml FILE] [--ignore-package-yaml] [--cache FILE] Generate a Nix expression for a Haskell package using Stack Available options: -o,--output DIR Generate output in DIR --stack-yaml FILE Override project stack.yaml (default: stack.yaml ) --ignore-package-yaml disable hpack run and use only cabal disregarding package.yaml existence --cache FILE Dependency cache file (default: .stack-to-nix.cache ) -h,--help Show this help text Use this for stack projects. If a default.nix does not exist in the output directory, it will create a basic one with a mkStackPkgSet function. Note If you find that there are missing files which should have been generated, remove .stack-to-nix.cache . (There's an open issue for this).","title":"stack-to-nix"},{"location":"reference/commands/#plan-to-nix","text":"plan-to-nix - a stack to nix converter Usage: plan-to-nix (-o|--output DIR) [--plan-json FILE] [--cabal-project FILE] [--cache FILE] Generate a Nix expression for a Haskell package using Cabal Available options: -o,--output DIR Generate output in DIR --plan-json FILE Override plan.json location (default: dist-newstyle/cache/plan.json ) --cabal-project FILE Override path to cabal.project (default: cabal.project ) --cache FILE Dependency cache file (default: .nix-tools.cache ) -h,--help Show this help text Use this for Cabal new-build projects (even if you don't have a cabal.project ). Before running, you need to create a plan. For more information, see Cabal Projects in the user guide. It will create a template default.nix in the output directory, unless that file already exists. Inside the output directory, there will be another directory .plan.nix , which contains Nix expressions for all local packages, generated by cabal-to-nix . The output file pkgs.nix refers to these files. Same note as above applies about the cache file.","title":"plan-to-nix"},{"location":"reference/commands/#cabal-to-nix","text":"Usage: cabal-to-nix FILE.cabal This writes (to stdout) a Haskell.nix Nix expression for the given cabal package. Normally, you do not need to run cabal-to-nix yourself. It is called by stack-to-nix and plan-to-nix .","title":"cabal-to-nix"},{"location":"reference/library/","text":"Haskell.nix contains a library of functions for creating buildable package sets from their Nix expression descriptions. The library is what you get when importing Haskell.nix . It might be helpful to load the library in the Nix REPL to test things. Types Package Set The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = X.Y.Z ; nix-name = ghcXYZ ; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset Haskell Package description Options for building a package. (todo: more info) Component description Options for building a component. (todo: more info) Haskell Package A derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; } Component Identifier A package identifier is an attrset pair of name and version . Extras Modules Top-level attributes mkStackPkgSet Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkCabalProjectPkgSet Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet mkPkgSet This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet snapshots This is an attrset of hsPkgs packages from Stackage. haskellPackages A hsPkgs package set nix-tools A derivation containing the nix-tools command-line tools . callStackToNix callCabalProjectToNix hackage stackage fetchExternal cleanSourceHaskell haskellLib Package-set functions These functions exist within the hsPkgs package set. shellFor Create a nix-shell development environment for developing one or more packages. shellFor = { packages, withHoogle ? true, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation ghcWithPackages ghcWithHoogle","title":"Haskell.nix Libary"},{"location":"reference/library/#types","text":"","title":"Types"},{"location":"reference/library/#package-set","text":"The result of mkPkgSet . This is an application of the NixOS module system. { options = { ... }; config = { hsPkgs = { ... }; packages = { ... }; compiler = { version = X.Y.Z ; nix-name = ghcXYZ ; packages = { ... }; }; }; } Attribute Type Description options Module options The combination of all options set through the modules argument passed to mkPkgsSet . config The result of evaluating and applying the options with Haskell.nix .hsPkgs Attrset of Haskell Packages Buildable packages, created from packages .packages Attrset of Haskell Package descriptions Configuration for each package in hsPkgs .compiler Attrset","title":"Package Set"},{"location":"reference/library/#haskell-package-description","text":"Options for building a package. (todo: more info)","title":"Haskell Package description"},{"location":"reference/library/#component-description","text":"Options for building a component. (todo: more info)","title":"Component description"},{"location":"reference/library/#haskell-package","text":"A derivation which has a components attribute. This derivation is actually just for the package Setup.hs script, and isn't very interesting. To actually use the package, look within the components structure. components = { library = COMPONENT; exes = { NAME = COMPONENT; }; tests = { NAME = COMPONENT; }; benchmarks = { NAME = COMPONENT; }; all = COMPONENT; }","title":"Haskell Package"},{"location":"reference/library/#component","text":"","title":"Component"},{"location":"reference/library/#identifier","text":"A package identifier is an attrset pair of name and version .","title":"Identifier"},{"location":"reference/library/#extras","text":"","title":"Extras"},{"location":"reference/library/#modules","text":"","title":"Modules"},{"location":"reference/library/#top-level-attributes","text":"","title":"Top-level attributes"},{"location":"reference/library/#mkstackpkgset","text":"Creates a package set based on the pkgs.nix output of stack-to-nix . mkStackPkgSet = { stack-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description stack-pkgs import ./pkgs.nix \u2014 The imported file generated by stack\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkStackPkgSet"},{"location":"reference/library/#mkcabalprojectpkgset","text":"Creates a package set based on the pkgs.nix output of plan-to-nix . mkCabalProjectPkgSet = { plan-pkgs, pkg-def-extras ? [], modules ? []}: ... Argument Type Description plan-pkgs import ./pkgs.nix \u2014 The imported file generated by plan\u2011to\u2011nix . pkg\u2011def\u2011extras List of Extras For overriding the package set. modules List of Modules For overriding the package set. Return value : a pkgSet","title":"mkCabalProjectPkgSet"},{"location":"reference/library/#mkpkgset","text":"This is the base function used by both mkStackPkgSet and mkCabalProjectPkgSet . Return value : a pkgSet","title":"mkPkgSet"},{"location":"reference/library/#snapshots","text":"This is an attrset of hsPkgs packages from Stackage.","title":"snapshots"},{"location":"reference/library/#haskellpackages","text":"A hsPkgs package set","title":"haskellPackages"},{"location":"reference/library/#nix-tools","text":"A derivation containing the nix-tools command-line tools .","title":"nix-tools"},{"location":"reference/library/#callstacktonix","text":"","title":"callStackToNix"},{"location":"reference/library/#callcabalprojecttonix","text":"","title":"callCabalProjectToNix"},{"location":"reference/library/#hackage","text":"","title":"hackage"},{"location":"reference/library/#stackage","text":"","title":"stackage"},{"location":"reference/library/#fetchexternal","text":"","title":"fetchExternal"},{"location":"reference/library/#cleansourcehaskell","text":"","title":"cleanSourceHaskell"},{"location":"reference/library/#haskelllib","text":"","title":"haskellLib"},{"location":"reference/library/#package-set-functions","text":"These functions exist within the hsPkgs package set.","title":"Package-set functions"},{"location":"reference/library/#shellfor","text":"Create a nix-shell development environment for developing one or more packages. shellFor = { packages, withHoogle ? true, ...}: ... Argument Type Description packages Function Package selection function. It takes a list of Haskell packages and returns a subset of these packages. withHoogle Boolean Whether to build a Hoogle documentation index and provide the hoogle command. { ... } Attrset All the other arguments are passed to mkDerivation . Return value : a derivation","title":"shellFor"},{"location":"reference/library/#ghcwithpackages","text":"","title":"ghcWithPackages"},{"location":"reference/library/#ghcwithhoogle","text":"","title":"ghcWithHoogle"},{"location":"reference/modules/","text":"Haskell.nix modules options for packages and components. Undocumented Please help write me.","title":"Module options"},{"location":"user-guide/cabal-projects/","text":"Here we will look into how to generate the pkgs.nix file for a cabal.project project. For the full integration see the previous page . Generating package sets for Cabal projects, is slightly more involved, because you need to let Cabal calculate a build plan for the dependencies of your package(s). Generating plan.json To get a plan, you need Cabal and GHC. See the Nixpkgs Manual for information about how to choose a specific compiler version. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run cabal new-configure If all goes well, you should now have the file dist-newstyle/cache/plan.json . Using plan-to-nix With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description. Creating the package set Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Cabal Projects"},{"location":"user-guide/cabal-projects/#generating-planjson","text":"To get a plan, you need Cabal and GHC. See the Nixpkgs Manual for information about how to choose a specific compiler version. For this example, we will run a nix-shell with the default GHC version for Nixpkgs. nix-shell -p haskellPackages.cabal-install haskellPackages.ghc \\ --run cabal new-configure If all goes well, you should now have the file dist-newstyle/cache/plan.json .","title":"Generating plan.json"},{"location":"user-guide/cabal-projects/#using-plan-to-nix","text":"With nix-tools installed , we can then run the following command on a Cabal project and its build plan. Omit the --cabal-project option if you don't have a project file. # convert the plan.json file into a pkgs.nix file plan-to-nix --output . \\ --plan-json dist-newstyle/cache/plan.json --cabal-project cabal.project This will produce a pkgs.nix file that looks like the following: { pkgs = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; }; extras = hackage: { packages = { my-package = ./.plan.nix/my-package.nix; }; }; } It has converted Cabal's build plan into a Nix expression that selects dependencies from hackage.nix . All local packages in the project are generated with cabal-to-nix and added to the package set description.","title":"Using plan-to-nix"},{"location":"user-guide/cabal-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkCabalPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = import ./pkgs.nix; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"},{"location":"user-guide/cross-compilation/","text":"Cross compilation of Haskell projects involves building a version of GHC that outputs code for the target platform, and providing builds of all library dependencies for that platform. First, understand how to cross-compile a normal package from Nixpkgs. Matthew Bauer's Beginners' guide to cross compilation in Nixpkgs is a useful resource. Using an example from the guide, this builds GNU Hello for a Raspberry Pi: nix build -f ' nixpkgs ' pkgsCross.raspberryPi.hello We will use the same principle in Haskell.nix \u2014 replacing the normal package set pkgs with a cross-compiling package set pkgsCross.raspberryPi . Raspberry Pi example This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags and so on. Static executables with Musl libc Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib --ghc-option=-optl=-L${zlib.static}/lib ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this.","title":"How to cross-compile your project"},{"location":"user-guide/cross-compilation/#raspberry-pi-example","text":"This is an example of using Haskell.nix to build the Bench command-line utility, which is a Haskell program. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); native = haskellNix { inherit pkgs; }; in native.haskellPackages.bench.components.exes.bench Now switch the package set as in the previous example: { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); raspberryPi = haskellNix { pkgs = pkgs.pkgsCross.raspberryPi; }; in raspberryPi.haskellPackages.bench.components.exes.bench You should be prepared for a long wait because it first needs to build GHC, before building all the Haskell dependencies of Bench . If all of these dependencies compiled successfully, I would be very surprised! To fix the build problems, you must add extra configuration to the package set. Your project will have a mkStackPkgSet or mkCabalProjectPkgSet . It is there where you must add module options for setting compiler flags and so on.","title":"Raspberry Pi example"},{"location":"user-guide/cross-compilation/#static-executables-with-musl-libc","text":"Another application of cross-compiling is to produce fully static binaries for Linux. For information about how to do that with the Nixpkgs Haskell infrastructure (not Haskell.nix ), see nh2/static\u2011haskell\u2011nix . Vaibhav Sagar's linked blog post is also very informative. { pkgs ? import nixpkgs {} }: let haskellNix = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz); musl64 = haskellNix { pkgs = pkgs.pkgsCross.musl64; }; in musl64.haskellPackages.bench.components.exes.bench This example will build Bench linked against Musl libc. However the executable will still be dynamically linked. To get fully static executables you must add package overrides to: Disable dynamic linking Provide static versions of system libraries. (For more details, see Vaibhav's article ). { packages.bench.components.exes.bench.configureFlags = stdenv.lib.optionals stdenv.hostPlatform.isMusl [ --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L${gmp6.override { withStatic = true; }}/lib --ghc-option=-optl=-L${zlib.static}/lib ]; } Licensing Note that if copyleft licensing your program is a problem for you, then you need to statically link with integer-simple rather than integer-gmp . However, at present, Haskell.nix does not provide an option for this.","title":"Static executables with Musl libc"},{"location":"user-guide/development/","text":"Haskell.nix also provides reproducible development environments for your Haskell projects. These environments can contain not only GHC and your Haskell package dependencies, but also the required system libraries and build tools. Inside the development shell, you can run commands such as ghc , ghci , or cabal new\u2011build , and they will have all dependencies available. Every dependency will be cached in your Nix store. If you have set up Hydra CI, then your team can share pre-built dependencies. These examples assume that you have created your package set as described in Creating Nix builds for your projects and it exists in a file called default.nix . Note Old-style cabal build and stack builds are not (yet) supported. For example, stack will (by design) download and rebuild all dependencies, even though they are available in the shell. However, if you have a Stack project, you can generate the package set with Haskell.nix, then use cabal new\u2011build to work on it. How to get a development shell for a package Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all How to get a development shell for a multi-package project If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import nixpkgs {} }; let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a hoogle command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). buildInputs = with pkgs.haskellPackages; [ hlint stylish-haskell ghcid ]; } How to get an ad-hoc development shell including certain packages This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages . How to get packages from a certain Stackage snapshot Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.snapshots. lts-13.18 .alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built. Emacs IDE support Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"How to create a development environment"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-package","text":"Run a nix\u2011shell on components.all of your package. all is a synthetic component whose dependencies are the union of the dependencies of all components in the package. Therefore, you will be able to build the test suites because their dependencies will be included. # shell.nix let hsPkgs = import ./default.nix {}; in hsPkgs.my-package.components.all","title":"How to get a development shell for a package"},{"location":"user-guide/development/#how-to-get-a-development-shell-for-a-multi-package-project","text":"If you have a Cabal or Stack project with multiple packages (i.e. multiple .cabal files, not a single package with multiple components), then you will need a development environment that contains the dependencies of your packages, but not the packages themselves. This is what the shellFor function does. # shell.nix { pkgs ? import nixpkgs {} }; let hsPkgs = import ./default.nix { inherit pkgs; }; in hsPkgs.shellFor { # Include only the *local* packages of your project. packages = ps: with ps; [ pkga pkgb ]; # Builds a Hoogle documentation index of all dependencies, # and provides a hoogle command to search the index. withHoogle = true; # You might want some extra tools in the shell (optional). buildInputs = with pkgs.haskellPackages; [ hlint stylish-haskell ghcid ]; }","title":"How to get a development shell for a multi-package project"},{"location":"user-guide/development/#how-to-get-an-ad-hoc-development-shell-including-certain-packages","text":"This creates a development environment with the given packages registered in the package database. The ghcWithPackages function operates on a Haskell.nix package set, and accepts an argument that selects packages from the larger package set. # shell.nix let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.haskellPackages.ghcWithPackages (ps: with ps; [ lens conduit conduit-extra ]) If you need a Hoogle documentation index, use ghcWithHoogle in place of ghcWithPackages .","title":"How to get an ad-hoc development shell including certain packages"},{"location":"user-guide/development/#how-to-get-packages-from-a-certain-stackage-snapshot","text":"Haskell.nix knows about every released Stackage snapshot. You can use it to build packages from a given snapshot, without setting up a full project. let haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; in haskell.snapshots. lts-13.18 .alex.components.exes.alex There are Haskell.nix package sets for every Stackage snaphot under haskell.snapshots . The alias haskell.haskellPackages corresponds to the package set for a recent LTS Haskell version. You can use ghcWithPackages on any of these package sets to quickly get a shell with some packages. Warning The build will not work if your Nixpkgs does not contain the version of GHC specified in the snapshot. Nixpkgs only carries the latest version of each recent release series, so many snapshots can't be built.","title":"How to get packages from a certain Stackage snapshot"},{"location":"user-guide/development/#emacs-ide-support","text":"Once you have a development shell, then you can begin configuring Emacs to use it. The way I do it is: Run lorri watch to continously build the shell environment and maintain GC roots. Use emacs\u2011direnv to push the development environment into Emacs. Use Dante for highlighting errors and auto-completion. You must customize Dante to prevent it from automatically using nix\u2011shell or stack . Trim dante\u2011methods to just new\u2011build and bare\u2011ghci . You can also use .dir\u2011locals.el for this. If your project has multiple targets, set dante\u2011target per-directory. For haskell\u2011mode interactive Haskell, set haskell\u2011process\u2011type to cabal\u2011new\u2011repl .","title":"Emacs IDE support"},{"location":"user-guide/projects/","text":"How to create Nix builds for your own private Haskell packages The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression. The following file then produces a package set: # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = haskell.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-overlays = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; ]; }; # Cabal projects use this: pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"Creating Nix builds for your projects"},{"location":"user-guide/projects/#how-to-create-nix-builds-for-your-own-private-haskell-packages","text":"The general structure will be the same, independent of the use of Stack or Cabal. Let us assume for now that we have already generated a pkgs.nix expression. The following file then produces a package set: # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./pkgs.nix; # Stack projects use this: pkgSet = haskell.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-overlays = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects ]; modules = [ # specific package overrides would go here # example: # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; ]; }; # Cabal projects use this: pkgSet = haskell.mkCabalProjectPkgSet { plan-pkgs = my-pkgs; pkg-def-extras = []; modules = []; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks. Generating a pkgs.nix for a Stack project Generating a pkgs.nix for a Cabal project","title":"How to create Nix builds for your own private Haskell packages"},{"location":"user-guide/stack-projects/","text":"Here we will look into how to generate the pkgs.nix file for a stack.yaml project. For the full integration see the previous page . Using stack-to-nix With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ). Creating the package set Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Stack Projects"},{"location":"user-guide/stack-projects/#using-stack-to-nix","text":"With nix-tools installed , we can simply run the following command on a stack project: stack-to-nix --output . --stack-yaml stack.yaml This will produce a pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1 ) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package ).","title":"Using stack-to-nix"},{"location":"user-guide/stack-projects/#creating-the-package-set","text":"Import the generated pkgs.nix and pass to mkStackPkgSet to instantiate a package set. # default.nix let # Import the Haskell.nix library, haskell = import (builtins.fetchTarball https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz) {}; # Instantiate a package set using the generated file. pkgSet = haskell.mkStackPkgSet { stack-pkgs = import ./pkgs.nix; pkg-def-overlays = []; modules = []; }; in pkgSet.config.hsPkgs","title":"Creating the package set"}]}