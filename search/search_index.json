{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"haskell.nix haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison. Motivation Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs cross compilation nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time. package sets We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides it's own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set. component level control The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue. cyclic dependencies The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components. build times The Haskell builder in nixpkgs build package sequentially, first the library than the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized you build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum. more logic in nix The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date. decoupling Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"Introduction"},{"location":"#haskellnix","text":"haskell.nix is an alternative Haskell infrastructure for nixpkgs. See Nixpkgs current Users' Guide to Haskell Infrastructure for comparison.","title":"haskell.nix"},{"location":"#motivation","text":"Why do we need another Haskell infrastructure for nix? Doesn't nixpkgs provide a sufficiently good Haskell infrastructure already? These are good questions. And it boils down to the following reasons for us to embark on a new infrastructure: first class support for cross compilation first class support for package sets component level control when building packages reduction of dontCheck for cyclic dependencies reducing build times by building libraries and tests in parallel more logic encoded in nix expressions decoupling of Haskell and nixpkgs","title":"Motivation"},{"location":"#cross-compilation","text":"nixpkgs has quite good support for cross compilation, however the Haskell infrastructure suffers from the fact that it heavily relies on the cabal2nix tool. cabal2nix (as well as tools that depend on it like stack2nix ) flattens the .cabal file at conversion time to a given os/arch/flags configuration. Thus to make cross compilation work with cabal2nix you will have to generate a separate nix expression for each configuration. This becomes a major maintenance burden over time. Therefore the tooling that translates cabal files into nix-expressions for use with Haskell.nix retains the full conditional tree from the cabal file and exposes it to nix . In addition it will also expose the build-type value, which allows us to cache the Setup.hs for build-type simple and not have to rebuild it every time.","title":"cross compilation"},{"location":"#package-sets","text":"We often rely on either package sets as provided by stackage or computed by cabal. nixpkgs provides it's own curated package set which might or might not work for the projects we work on. stack2nix tries to solve this issue, here we go one step further and provide the infrastructure to allow any form of package set.","title":"package sets"},{"location":"#component-level-control","text":"The Haskell builder in nixpkgs provides control over executables and libraries, to build a specific executable only however is rather tricky to do. This also leads to the cyclic dependencies issue.","title":"component level control"},{"location":"#cyclic-dependencies","text":"The Haskell builder in nixpkgs exposes packages at the package level. If packages mutually depend on each other through tests and libraries, this leads to cyclic dependencies that nix can't resolve. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.","title":"cyclic dependencies"},{"location":"#build-times","text":"The Haskell builder in nixpkgs build package sequentially, first the library than the executables and finally the tests. It then executes the tests before the package is considered done. The upshot of this is that packages are only considered done if the test-suites passed. The downside is that if you have to compile multiple packages the likelihood of them failing is low, you have unnecessarily serialized you build. In a more aggressive setting libraries could start building as early as their dependent libraries are built. Of course they will have to be invalidated later should the test-suites of their dependencies fail, but this way we can make use of parallel building. In an ideal scenario this will reduce build times close to the optimum.","title":"build times"},{"location":"#more-logic-in-nix","text":"The cabal2nix tool has a resolver that resolves system dependencies and licenses to values in nixpkgs . This logic ends up being a simple dictionary lookup and therefore can be a simple nix expression. This also offloads some of the work the cabal to nix translation tool needs to do into nix, and as such if changes are necessary (or needed to be performed ad hoc) there is no need to rebuild the conversion tool and subsequently mark every derived expression as out of date.","title":"more logic in nix"},{"location":"#decoupling","text":"Finally, by treating Haskell.nix and nixpkgs as separate entities we can decouple the Haskell packages and infrastructure from the nixpkgs package set, and rely on it to provide us with system packages while staying up to date with Haskell packages from hackage while retaining a stable (or known to be good) nixpkgs revision.","title":"decoupling"},{"location":"architecture/","text":"Architecture There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram nix-tools nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix . haskell.nix haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own. hackage.nix hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage. stackage.nix stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"Architecture"},{"location":"architecture/#architecture","text":"There are multiple components that play a part in the haskell.nix infrastructure. These are nix-tools , haskell.nix , hackage.nix , and stackage.nix . .-------------. .-------------. .- nix-tools ------. | haskell.nix | .- | hackage.nix | | .--------------. | .----------------. '-------------' | '-------------' | | stack-to-nix |--- | stack-pkgs.nix |-. | | | | '--------------' | '----------------' | v | v | .-------------. | .----------. '-- .----------. -' .--------------. | | plan-to-nix |---- | plan.nix |------.--- | pkgs.nix | --- | stackage.nix | | '-------------' | '----------' | '----------' '--------------' | .--------------. | .--------------. | | | | cabal-to-nix |--- | $package.nix |--' v | '--------------' | '--------------' .-------------. '------------------' | default.nix | '-------------' | v .-------------. | release.nix | '-------------' haskell.nix diagram","title":"Architecture"},{"location":"architecture/#nix-tools","text":"nix-tools is a Haskell package that provides the following tools: cabal-to-nix : a .cabal to .nix transformer that retains conditional expressions. stack-to-nix : a stack.yaml to .nix transformer that will read in a stack.yaml expression an generate a pkgs.nix file suited for use with haskell.nix . plan-to-nix : a plan.json to .nix transformer that will read in a plan.json file and generate a pkgs.nix file suited for use with haskell.nix . as well as a few other tools used to generate hackage.nix and stackage.nix .","title":"nix-tools"},{"location":"architecture/#haskellnix","text":"haskell.nix is the runtime system for this Haskell infrastructure. It contains the component builder, as well as the system package and license mapping. Without haskell.nix the expressions generated by either of the nix-tools tools make little sense on their own.","title":"haskell.nix"},{"location":"architecture/#hackagenix","text":"hackage.nix provides all cabal expressions from hackage as nix expressions. It is periodically updated to keep in sync with the set of packages available on hackage.","title":"hackage.nix"},{"location":"architecture/#stackagenix","text":"stackage.nix is similar to hackage.nix but provides all stackage snapshots (lts, and nightly) as nix expressions. It naturally depends on hackage.nix to resolve package names, versions and revisions to the repsective packages from hackage.nix.","title":"stackage.nix"},{"location":"dev-architecture/","text":"Developer Architecture Overview This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble. Packages haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix . Plans Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section. Package Sets (of derivations) We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ). Component builder To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Architecture"},{"location":"dev-architecture/#developer-architecture-overview","text":"This shall give a sufficiently good overview over the haskell.nix ideas, such that a new developer can navigate around without too much trouble.","title":"Developer Architecture Overview"},{"location":"dev-architecture/#packages","text":"haskell.nix is centered around packages (haskell package descriptions as nix-expressions). These are generated by cabal-to-nix from the nix-tools package. stack-to-nix and plan-to-nix will delegate the transformation of cabal packages to nix expressions to the same code that cabal-to-nix uses. These packages will look similar to the following: { system, compiler, flags, pkgs, hsPkgs, pkgconfPkgs, ... }: { flags = {}; package = { ... }; components = { library = { depends = [ ... ]; }; exes = { ... = { depends = [ ... ]; }; ... }; sublibs = { ... = { depends = [ ... ]; }; ... }; tests = { ... = { depends = [ ... ]; }; ... }; benchmarks = { ... = { depends = [ ... ]; }; ... }; }; }; The exact specification can be found in modules/package.nix .","title":"Packages"},{"location":"dev-architecture/#plans","text":"Packages (unless specified directly in the packages attribute of the module) usually come from a plan. A plan is either a Stackage snapshot (nightly or LTS) or a build plan as produced by cabal . Plan files usually look like the following: hackage: { packages = { $pkg .revision = hackage.$pkg.$version.revisions.default; $pkg .flags = { flag1 = true; flag2 = false; ... }; ... }; compiler = { version = 8.4.4 ; nix-name = ghc844 ; packages = { binary = 0.8.5.1 ; ... }; }; } This provides enough information about the compiler, what packages the compiler ships with and the packages we want to use in our plan. This revision and flag information will be inlined into a list of packages in config.packages in modules/plan.nix . Thus config.packages will only contains packages as described in the previous section.","title":"Plans"},{"location":"dev-architecture/#package-sets-of-derivations","text":"We finally tie this all together in package-set.nix where we use modules/component-driver.nix to produce the derivations for each packages component to produce the final config.hsPkgs value. There is also a modules/compat-driver.nix that should produce the same packageset to be used with the stock haskell infrastructure in nixpkgs ( This has undergone substantially less testing ).","title":"Package Sets (of derivations)"},{"location":"dev-architecture/#component-builder","text":"To prevent depending on mutliple instances of the same libraries, the component builder will try to build every package from scratch and rely as little as possible on packages that are shipped with the GHC distribution. The exceptions are packages that are known to not be reinstallable. See config.nonReinstallablePkgs . The component builder can be found in modules/component-driver.nix and builder/default.nix . The component-driver will ensure that we do not try to rebuild non-reinstallable packages, and call the builder/default.nix on each package in config.packages to produce config.hsPkgs .","title":"Component builder"},{"location":"iohk-nix/","text":"IOHK's nix tooling iohk-nix iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"IOHKs nix library"},{"location":"iohk-nix/#iohks-nix-tooling","text":"","title":"IOHK's nix tooling"},{"location":"iohk-nix/#iohk-nix","text":"iohk-nix is IOHK's shared nix library. It provides some templates to make working with haskell.nix trivial but is non-essential to use haskell.nix infrastructure. lib.nix let # iohk-nix can be overridden for debugging purposes by setting # NIX_PATH=iohk_nix=/path/to/iohk-nix iohkNix = import ( let try = builtins.tryEval iohk_nix ; in if try.success then builtins.trace using host iohk_nix try.value else let spec = builtins.fromJSON (builtins.readFile ./iohk-nix.json); in builtins.fetchTarball { url = ${spec.url}/archive/${spec.rev}.tar.gz ; inherit (spec) sha256; }) {}; pkgs = iohkNix.pkgs; lib = pkgs.lib; in lib // { inherit iohkNix pkgs; inherit (iohkNix) nix-tools; } iohk-nix.json { url : https://github.com/input-output-hk/iohk-nix , rev : c92f0119ef5814b0ed1f445c2fdcf8894e326294 , sha256 : 05r90x6x3yp1nb66rkc4n0i8q15c634rrdsr2zvb118s3sdcmmrm , fetchSubmodules : false } nix/pkgs.nix { pkgs ? import nixpkgs {} , iohk-extras ? {} , iohk-module ? {} , haskell , hackage , stackage , ... }: let # our packages stack-pkgs = import ./.stack-pkgs.nix; # Build the packageset with module support. # We can essentially override anything in the modules # section. # # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; # compiler = (stack-pkgs.extras hackage).compiler.nix-name; pkgSet = haskell.mkNewPkgSet { inherit pkgs; pkg-def = stackage.${stack-pkgs.resolver}; # These extras allow extension or restriction of the set of # packages we are interested in. By using the stack-pkgs.extras # we restrict our package set to the ones provided in stack.yaml. pkg-def-extras = [ stack-pkgs.extras iohk-extras.${compiler} ]; # package customizations modules = [ # This module will ensure that we get the necessary # patches ontop of GHC packages that for which the # ones that GHC ships are not identical to the ones # we find on hackage. These patches will make sure # they are identical by augmenting the packages on # hackage to match those that ship with ghc. haskell.ghcHackagePatches.${compiler} # the iohk-module will supply us with the necessary # cross compilation plumbing to make Template Haskell # work when cross compiling. For now we need to # list the packages that require template haskell # explicity here. iohk-module ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } default.nix let localLib = import ./lib.nix; in # This file needs to export a function that takes # the arguments it is passed and forwards them to # the default-nix template from iohk-nix. This is # important so that the release.nix file can properly # parameterize this file when targetting different # hosts. { ... }@args: # We will instantiate the defaul-nix template with the # nix/pkgs.nix file... localLib.nix-tools.default-nix ./nix/pkgs.nix args # ... and add a few custom packages as well. // { }","title":"iohk-nix"},{"location":"maintainer-scripts/","text":"Updating Hackage and Stackage Nix expressions The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Maintainer Scripts"},{"location":"maintainer-scripts/#updating-hackage-and-stackage-nix-expressions","text":"The hackage.nix and stackage.nix repos and corresponding files hackage-src.json and stackage-src.json will be regularly and automatically updated using scripts in this repo. To run the updater scripts manually, use: nix-build -A maintainer-scripts.update-hackage -o update-hackage.sh ./update-hackage.sh nix-build -A maintainer-scripts.update-stackage -o update-stackage.sh ./update-stackage.sh The scripts will clone the repo, generate the latest data, then attempt to push back to the repo and update the source JSON file.","title":"Updating Hackage and Stackage Nix expressions"},{"location":"migrations/","text":"overlay to extras overlay was renamed to extras in #79 to prevent confusion between the notion of nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras . Drop th-packages When using iohk-nix to facility cross compilation, we used to require explicit listing of packages that required TemplateHaskell , this was dropped in iohk-nix@da7c1ed , see #92. As such the th-packages and nixpkgs argument were dropped from the iohk-module .","title":"`overlay` to `extras`"},{"location":"migrations/#overlay-to-extras","text":"overlay was renamed to extras in #79 to prevent confusion between the notion of nix overlays. Therefore plan-pkgs and stack-pkgs as generated by plan-to-nix and stack-to-nix will expose extras instead of overlay . Similarly mkStackPkgSet , mkPkgSet and mkCabalProjectPkgSet take a pkg-def-extras instead of pkg-def-overlay argument. If you are using iohk-nix , the iohk-overlay was parameter was renamed to iohk-extras .","title":"overlay to extras"},{"location":"migrations/#drop-th-packages","text":"When using iohk-nix to facility cross compilation, we used to require explicit listing of packages that required TemplateHaskell , this was dropped in iohk-nix@da7c1ed , see #92. As such the th-packages and nixpkgs argument were dropped from the iohk-module .","title":"Drop th-packages"},{"location":"removing-with-package-wrapper/","text":"ghcWithPackages wrapper removal The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone. Plain ghc When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well. ghc-pkg The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set. Setup.hs When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages. cabal new-build Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"Removing withPackage wrapper"},{"location":"removing-with-package-wrapper/#ghcwithpackages-wrapper-removal","text":"The current Nixpkgs Haskell infrastructure and haskell.nix both provide a ghcWithPackages derivation which contains shell script wrappers that wrap ghc and ghc-pkg . In the Nixpkgs Haskell infrastructure, the wrapper scripts are used for building Haskell packages. However, in haskell.nix , the wrappers are only used for development environments. The wrapper scripts provide a ghc command that \"knows\" about the package set and has all Haskell package dependencies available to it. We would like to remove the wrapper scripts, but it's currently not possible to configure all build tools using environment variables alone.","title":"ghcWithPackages wrapper removal"},{"location":"removing-with-package-wrapper/#plain-ghc","text":"When using ghc or ghci by itself, the GHC_ENVIRONMENT variable can point to a configuration file containing an exact package set. This works quite well.","title":"Plain ghc"},{"location":"removing-with-package-wrapper/#ghc-pkg","text":"The package tool ghc-pkg does not recognize GHC_ENVIRONMENT , but does recognize a GHC_PACKAGE_PATH pointing to a package.conf.d . This works well. However, the cabal command will refuse to start if GHC_PACKAGE_PATH is set.","title":"ghc-pkg"},{"location":"removing-with-package-wrapper/#setuphs","text":"When invoking Setup.hs configure , the package database is provided with the --package-db argument and exact dependencies in the package set can be provided as --dependency arguments. The haskell.nix component builder uses Setup.hs with these command-line options to build Haskell packages.","title":"Setup.hs"},{"location":"removing-with-package-wrapper/#cabal-new-build","text":"Cabal-install will observe the CABAL_CONFIG environment variable, which points to a cabal config file. This config file can provide a package-db value, but it can't specify exact versions of packages. Cabal is designed to solve dependencies, not simply take the package set which is given to it. Therefore, cabal does not use GHC_ENVIRONMENT , but instead creates its own environment file. It will not accept --dependency arguments. As far as I know, the best way to force cabal to take a pre-computed package set is to use a new-freeze file. However there is no environment variable (or config file entry) which can specify a path to a freeze file. Specifying a package-db path in the cabal config file is not enough for it to successfully resolve dependencies. As mentioned before, cabal does not work when GHC_PACKAGE_PATH is set. The best way to work around this is to wrap ghc and ghc-pkg in shell scripts.","title":"cabal new-build"},{"location":"user-guide-cabal/","text":"User Guide (cabal project) Here we will look into how to generate the pkgs.nix file for a cabal.project project. For the full integration please see the User Guide Using plan-to-nix We currently don't have a project-to-nix tool yet, as such creating the relevant pkgs.nix file for a cabal.project is slightly more involved than for a corresponding stack project . With nix-tools in PATH , we can simply run the following command on a cabal package: # make sure the cabal project is configured (the plan.json file is generated) cabal new-configure # convert the plan.json file into a pkgs.nix file plan-to-nix dist-newstyle/cache/plan.json nix/plan.nix This will produce a nix/plan.nix file that looks like the following: hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; } it specifically does not include any of our local packages yet. We will need to run cabal-to-nix $path nix/$pkg.nix or cabal-to-nix $url $rev nix/$pkg.nix for each local (or source) package. With this in place we can then proceed to build the nix/pkgs.nix file as follows: let plan = import ./plan.nix; in { pkg-def = plan; extras = { local-package-a = ./local-package-a.nix; local-package-b = ./local-package-b.nix; source-import-a = ./source-import-a.nix; source-import-b = ./source-import-b.nix; ... }; } If you came here from the User Guide , go back and complete the setup.","title":"Cabal Proejcts"},{"location":"user-guide-cabal/#user-guide-cabal-project","text":"Here we will look into how to generate the pkgs.nix file for a cabal.project project. For the full integration please see the User Guide","title":"User Guide (cabal project)"},{"location":"user-guide-cabal/#using-plan-to-nix","text":"We currently don't have a project-to-nix tool yet, as such creating the relevant pkgs.nix file for a cabal.project is slightly more involved than for a corresponding stack project . With nix-tools in PATH , we can simply run the following command on a cabal package: # make sure the cabal project is configured (the plan.json file is generated) cabal new-configure # convert the plan.json file into a pkgs.nix file plan-to-nix dist-newstyle/cache/plan.json nix/plan.nix This will produce a nix/plan.nix file that looks like the following: hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... }; compiler = { ... }; } it specifically does not include any of our local packages yet. We will need to run cabal-to-nix $path nix/$pkg.nix or cabal-to-nix $url $rev nix/$pkg.nix for each local (or source) package. With this in place we can then proceed to build the nix/pkgs.nix file as follows: let plan = import ./plan.nix; in { pkg-def = plan; extras = { local-package-a = ./local-package-a.nix; local-package-b = ./local-package-b.nix; source-import-a = ./source-import-a.nix; source-import-b = ./source-import-b.nix; ... }; } If you came here from the User Guide , go back and complete the setup.","title":"Using plan-to-nix"},{"location":"user-guide-stack/","text":"User Guide (stack project) Here we will look into how to generate the pkgs.nix file for a stack.yaml project. For the full integration please see the User Guide Using stack-to-nix With nix-tools in PATH , we can simply run the following command on a stack project: stack-to-nix -o nix --stack-yaml stack.yaml This will produce a nix/pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package). If you came here from the User Guide , go back and complete the setup.","title":"Stack Projects"},{"location":"user-guide-stack/#user-guide-stack-project","text":"Here we will look into how to generate the pkgs.nix file for a stack.yaml project. For the full integration please see the User Guide","title":"User Guide (stack project)"},{"location":"user-guide-stack/#using-stack-to-nix","text":"With nix-tools in PATH , we can simply run the following command on a stack project: stack-to-nix -o nix --stack-yaml stack.yaml This will produce a nix/pkgs.nix file that looks like the following: { resolver = lts-12.17 ; extras = hackage: { packages = { o-clock = hackage.o-clock. 0.1.1 .revisions.default; ... } // { my-package = ./my-package.nix; ... }; }; } This file contains the stackage resolver, as well as set of extra packages. The extras specifies which extra-deps (here: o-clock-0.1.1) we wanted to add over the stackage snapshot, and what local packages we want (here: my-package). If you came here from the User Guide , go back and complete the setup.","title":"Using stack-to-nix"},{"location":"user-guide/","text":"User Guide So you want to use haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expressions. Getting a copy of the haskell.nix, hackage.nix (and potentially stackage.nix) source will then equip us to produce derivations that we can nix build . Installing nix-tools To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt Setup The general structure will be the same for haskell.nix, independent of the use of stack or cabal. Let us assume for now that we have generated a pkgs.nix expression in nix . Generating a pkgs.nix for a stack project Generating a pkgs.nix for a cabal project default.nix We will start with defining a helper function in our default.nix that will allow us to override the source imports with -I haskell=/path/to/haskell.nix in case we need it. { pkgs ? import nixpkgs {} }: let overrideWith = override: default: let try = builtins.tryEval (builtins.findFile builtins.nixPath override); in if try.success then builtins.trace using search host ${override} try.value else default; in Next we will use this to import haskell.nix . NOTE : update the rev and sha256 values to the recent ones as found on GitHub. Especially haskell.hackage and haskell.stackage will evolve with package release on hackage and stackage releases respectively. let haskellLib = pkgs.fetchFromGitHub { owner = input-output-hk ; repo = haskell.nix ; rev = 5180ae9d78756509c81b98b8e6d974e350b15752 ; sha256 = 0fbnnvymdp2qb09wlqy6ga8wsyhglx607cjdfg510s1gs756v9yx ; name = haskell-lib-source ; }; haskell = import (overrideWith haskell haskellLib) { inherit pkgs; }; in Finally we string this together and produce a package set: let # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./nix/pkgs.nix; # Stack projects use the mkStackPkgSet helper function pkgSet = haskell.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-overlays = []; modules = []; }; # Cabal projects use mkPkgSet pkgSet = haskell.mkPkgSet { pkg-def = my-pkgs.pkg-def; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects my-pkgs.extras ]; modules = [ # specific package overrides would go here # example: # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks.","title":"General"},{"location":"user-guide/#user-guide","text":"So you want to use haskell.nix with your stack or cabal project. The general approach will be to pick the right tool from nix-tools and produce a pkgs.nix expressions. Getting a copy of the haskell.nix, hackage.nix (and potentially stackage.nix) source will then equip us to produce derivations that we can nix build .","title":"User Guide"},{"location":"user-guide/#installing-nix-tools","text":"To build the latest nix-tools and store the result at ./nt , run: nix build -f https://github.com/input-output-hk/haskell.nix/archive/master.tar.gz nix-tools --out-link nt If you would like to then install nix-tools into your profile, run: nix-env -i ./nt","title":"Installing nix-tools"},{"location":"user-guide/#setup","text":"The general structure will be the same for haskell.nix, independent of the use of stack or cabal. Let us assume for now that we have generated a pkgs.nix expression in nix . Generating a pkgs.nix for a stack project Generating a pkgs.nix for a cabal project","title":"Setup"},{"location":"user-guide/#defaultnix","text":"We will start with defining a helper function in our default.nix that will allow us to override the source imports with -I haskell=/path/to/haskell.nix in case we need it. { pkgs ? import nixpkgs {} }: let overrideWith = override: default: let try = builtins.tryEval (builtins.findFile builtins.nixPath override); in if try.success then builtins.trace using search host ${override} try.value else default; in Next we will use this to import haskell.nix . NOTE : update the rev and sha256 values to the recent ones as found on GitHub. Especially haskell.hackage and haskell.stackage will evolve with package release on hackage and stackage releases respectively. let haskellLib = pkgs.fetchFromGitHub { owner = input-output-hk ; repo = haskell.nix ; rev = 5180ae9d78756509c81b98b8e6d974e350b15752 ; sha256 = 0fbnnvymdp2qb09wlqy6ga8wsyhglx607cjdfg510s1gs756v9yx ; name = haskell-lib-source ; }; haskell = import (overrideWith haskell haskellLib) { inherit pkgs; }; in Finally we string this together and produce a package set: let # Import the file you will create in the stack-to-nix or cabal-to-nix step. my-pkgs = import ./nix/pkgs.nix; # Stack projects use the mkStackPkgSet helper function pkgSet = haskell.mkStackPkgSet { stack-pkgs = my-pkgs; pkg-def-overlays = []; modules = []; }; # Cabal projects use mkPkgSet pkgSet = haskell.mkPkgSet { pkg-def = my-pkgs.pkg-def; pkg-def-extras = [ # these extras will provide additional packages # ontop of the package set. E.g. extra-deps # for stack packages. or local packages for # cabal.projects my-pkgs.extras ]; modules = [ # specific package overrides would go here # example: # packages.cbors.patches = [ ./one.patch ]; # packages.cbors.flags.optimize-gmp = false; ]; }; in pkgSet.config.hsPkgs // { _config = pkgSet.config; } With this setup you can then start building the components of interest: nix build -f default.nix $pkg.components.library to build the library for $pkg or nix build -f default.nix $pkg.components.exes.$exe to build a specific executable. The same holds for test suites and benchmarks.","title":"default.nix"}]}